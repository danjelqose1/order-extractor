<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Order Extractor — Local</title>
  <style>
    :root{
      --bg:#f5f6fb;
      --card-bg:#ffffff;
      --border:#dfe3eb;
      --border-dark:#ccd2df;
      --text:#1c2434;
      --muted:#6b7280;
      --primary:#4c5cff;
      --primary-soft:#eef1ff;
      --danger:#f87171;
      --shadow:0 6px 20px rgba(20,34,66,0.08);
      --ms-sans-system:-apple-system,system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      --ms-inter-stack:"Inter",var(--ms-sans-system);
      --ms-roboto-stack:"Roboto",var(--ms-sans-system);
      --ms-mono-stack:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
      --ms-header-size:20px;
      --ms-subheader-size:14px;
      --ms-body-size:12.5px;
      --ms-body-line-height:1.4;
      --ms-row-spacing-adjust:0px;
      --ms-accent-color:#2F6BFF;
    }
    *,*::before,*::after{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Helvetica,Arial,sans-serif;line-height:1.5}
    main.app{max-width:1100px;margin:0 auto;padding:24px 18px 48px}
    .app-header h1{margin:0;font-size:24px;font-weight:600}
    .app-header p{margin:6px 0 0;color:var(--muted);font-size:14px}
    .tab-bar{display:flex;gap:8px;margin:24px 0 16px;background:rgba(255,255,255,0.6);padding:4px;border-radius:12px;border:1px solid rgba(207,215,231,0.6);backdrop-filter:blur(6px)}
    .tab-bar button{flex:1;border:none;background:none;padding:10px 14px;border-radius:10px;font-weight:600;color:var(--muted);cursor:pointer;transition:all .2s ease}
    .tab-bar button.active{background:var(--card-bg);color:var(--text);box-shadow:var(--shadow)}
    .tab-panel{display:none}
    .tab-panel.active{display:block}
    .card{background:var(--card-bg);border:1px solid var(--border);border-radius:16px;box-shadow:var(--shadow);padding:18px;margin-bottom:18px}
    .card h2{margin:0;font-size:18px;font-weight:600}
    textarea{width:100%;min-height:220px;padding:14px 16px;border:1px solid var(--border-dark);border-radius:12px;font-size:14px;resize:vertical;background:#fbfcff}
    textarea:focus{outline:2px solid var(--primary-soft);border-color:var(--primary)}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px}
    button{font:inherit}
    .btn{border:1px solid var(--border-dark);background:#f9fafe;color:var(--text);padding:8px 14px;border-radius:10px;cursor:pointer;transition:background .2s ease,transform .2s ease}
    .btn:hover{background:#eef1ff10;transform:translateY(-1px)}
    .btn.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    .btn.primary:hover{background:#4352ff}
    .btn.success{background:#10b981;border-color:#0d946b;color:#fff}
    .btn.success:hover{background:#0b8360}
    .btn.small{padding:6px 10px;font-size:13px}
    .btn.ghost{background:transparent;border:none;color:var(--primary)}
    .btn.danger{border-color:#fca5a5;background:#fee2e2;color:#b91c1c}
    .inline-toggle{display:flex;align-items:center;gap:6px;font-size:14px;color:var(--muted)}
    [data-group-toggle]{width:18px;height:18px}
    .status-row{display:flex;flex-wrap:wrap;justify-content:space-between;gap:10px;margin-top:12px}
    .muted{color:var(--muted)}
    .small{font-size:13px}
    .summary{margin:14px 0 10px;font-weight:600;font-size:15px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .pill{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:999px;background:var(--primary-soft);color:var(--primary);font-size:12px}
    .pill.warn{background:#fef3c7;color:#b45309}
    .table-responsive{width:100%;overflow-x:auto;border-radius:12px;border:1px solid var(--border);background:var(--card-bg)}
    table{width:100%;border-collapse:collapse;min-width:640px}
    th,td{padding:8px 10px;border-bottom:1px solid var(--border);font-size:14px;text-align:left;vertical-align:top}
    th{background:#f4f6ff;color:#485163;font-weight:600}
    tr:last-child td{border-bottom:none}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .dropzone{margin-top:12px;padding:26px;border:2px dashed #c9cfea;border-radius:14px;text-align:center;color:var(--muted);background:#fbfcff;cursor:pointer;transition:border-color .2s ease,background .2s ease}
    .dropzone.hover{background:var(--primary-soft);border-color:var(--primary);color:var(--text)}
    details{margin-left:auto;font-size:13px}
    details summary{cursor:pointer;color:var(--muted)}
    code{background:#f0f2f8;padding:2px 6px;border-radius:6px;font-size:12px}
    .labels-controls{display:flex;flex-wrap:wrap;gap:8px;margin:16px 0 10px}
    .labels-summary{display:flex;flex-wrap:wrap;gap:10px;font-size:13px;color:var(--muted)}
    .labels-empty{padding:24px;text-align:center;color:var(--muted)}
    .alert{background:#fef2f2;border:1px solid #fecaca;color:#b91c1c;padding:10px 12px;border-radius:10px;margin-top:14px}
    .alert[hidden]{display:none}
    .toast{display:flex;align-items:center;gap:8px;background:var(--primary-soft);border:1px solid var(--primary);color:var(--primary);padding:8px 12px;border-radius:10px;margin-bottom:16px}
    .toast[hidden]{display:none}
    .link-button{background:none;border:none;padding:0;color:var(--primary);cursor:pointer;font-weight:600}
    .link-button.muted{color:var(--muted);font-weight:500}
    .settings-card h3{margin:0 0 12px;font-size:17px;font-weight:600}
    .appearance-form{display:flex;flex-direction:column;gap:18px}
    .appearance-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:16px}
    .appearance-field{display:flex;flex-direction:column;gap:8px;font-size:14px;color:var(--text)}
    .appearance-label{font-weight:600;font-size:13px;color:var(--muted)}
    .appearance-range{display:flex;align-items:center;gap:10px}
    .appearance-range input[type=range]{flex:1}
    .appearance-value{min-width:48px;text-align:right;font-variant-numeric:tabular-nums;color:var(--muted);font-size:13px}
    .appearance-select{width:100%;padding:8px 12px;border:1px solid var(--border-dark);border-radius:10px;font-size:14px;background:#fbfcff;color:var(--text)}
    .appearance-select:focus{outline:2px solid var(--primary-soft);border-color:var(--primary)}
    .appearance-actions{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .appearance-feedback{min-height:18px;font-size:13px;color:var(--muted)}
    .appearance-hint{margin:0;font-size:12px;color:var(--muted)}
    #appearanceForm .btn.ghost{color:var(--primary);border-color:transparent;background:none;padding-left:0;padding-right:0}
    .history-filters .filters-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;align-items:flex-end}
    .history-filters label{display:flex;flex-direction:column;gap:6px;font-size:13px;font-weight:500;color:var(--muted)}
    .history-filters input,.history-filters select{padding:8px 10px;border:1px solid var(--border-dark);border-radius:10px;font-size:14px}
    .history-filters input:focus,.history-filters select:focus{outline:2px solid var(--primary-soft);border-color:var(--primary)}
    .filter-actions{display:flex;align-items:center;gap:8px}
    .history-pagination{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:14px}
    .badge{display:inline-flex;align-items:center;padding:4px 8px;border-radius:999px;background:#f3f4f6;color:var(--muted);font-size:12px;font-weight:600}
    .badge.offline{background:#fef3c7;color:#b45309}
    .history-detail-header{display:flex;justify-content:space-between;flex-wrap:wrap;gap:12px;align-items:center;margin-bottom:12px}
    .history-detail-actions{display:flex;gap:8px}
    .history-detail-subheader{display:flex;justify-content:space-between;flex-wrap:wrap;gap:12px;align-items:center;margin-bottom:10px}
    .history-empty,.empty-state{padding:16px;border-radius:12px;background:#f8f9ff;border:1px dashed var(--border);text-align:center;color:var(--muted);font-size:14px}
    .actions-cell{display:flex;flex-wrap:wrap;gap:6px}
    .actions-cell .btn.small{padding:5px 8px}
    .spinner{display:inline-block;width:16px;height:16px;border:2px solid #d8ddf0;border-top-color:var(--primary);border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle}
    .warning-list{margin:12px 0;padding:12px;border-radius:10px;background:#fff8e1;border:1px solid #fde68a;color:#92400e;font-size:13px}
    .warning-list h4{margin:0 0 6px;font-size:13px;font-weight:600}
    .warning-list ul{margin:0;padding-left:18px}
    .warning-badge{display:inline-flex;align-items:center;gap:6px;background:#fee2e2;color:#991b1b;padding:0 8px;border-radius:999px;font-size:11px}
    .editable-table input,.editable-table select{width:100%;padding:6px 8px;border:1px solid var(--border-dark);border-radius:8px;font-size:13px;background:#fff}
    .editable-table input:focus{outline:2px solid var(--primary-soft);border-color:var(--primary)}
    .editable-badge{display:inline-flex;align-items:center;padding:2px 6px;border-radius:6px;background:#fee2e2;color:#9f1239;font-size:11px}
    .notes-field{margin-top:12px;display:flex;flex-direction:column;gap:6px}
    .notes-field textarea{width:100%;min-height:80px;padding:10px;border:1px solid var(--border-dark);border-radius:10px;font-size:13px;resize:vertical;background:#fff}
    .processing-layout{display:grid;grid-template-columns:280px 1fr 280px;gap:18px;margin-top:12px}
    .processing-sidebar,.processing-controls{display:flex;flex-direction:column;gap:12px}
    .processing-order-list{border:1px solid var(--border);border-radius:12px;background:var(--card-bg);padding:12px;max-height:420px;overflow:auto;display:flex;flex-direction:column;gap:10px}
    .processing-order-item{border:1px dashed var(--border-dark);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:6px;background:#f8f9ff}
    .processing-order-item header{display:flex;justify-content:space-between;align-items:center;font-weight:600}
    .processing-preview{
      border:1px solid var(--border);
      border-radius:12px;
      background:#1f2435;
      color:#f8f9ff;
      padding:16px;
      min-height:320px;
      max-height:560px;
      overflow:auto;
      white-space:pre-wrap;
      font-family:var(--ms-family-rows);
      font-size:var(--ms-body-size);
      line-height:var(--ms-body-line-height);
    }
    .processing-meta{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;font-size:13px;color:var(--muted)}
    .processing-controls .card{padding:14px}
    .processing-controls .toggle-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;font-size:13px}
    .processing-controls .toggle-row:last-child{margin-bottom:0}
    .processing-controls label{display:flex;justify-content:space-between;gap:8px;font-size:13px}
    .processing-empty{border:1px dashed var(--border-dark);border-radius:12px;padding:16px;text-align:center;color:var(--muted)}
    .processing-header-editor{display:flex;flex-direction:column;gap:8px}
    .processing-header-editor select,.processing-header-editor input{padding:8px;border:1px solid var(--border-dark);border-radius:8px;font-size:13px;width:100%;background:#fff}
    .processing-actions{display:flex;flex-direction:column;gap:8px}
    .processing-actions .btn{width:100%}
    .processing-warning{color:#facc15;font-size:12px;margin-top:6px}
    #motherSheet,.mother-sheet{--ms-family-base:var(--ms-sans-system);--ms-family-header:var(--ms-sans-system);--ms-family-rows:var(--ms-sans-system);background:#fff;color:#131722;font-family:var(--ms-family-base);line-height:var(--ms-body-line-height);font-size:var(--ms-body-size)}
    #motherSheet h1,.mother-sheet h1{font-family:var(--ms-family-header);font-size:var(--ms-header-size);font-weight:700;margin:0 0 12px}
    #motherSheet .ms-order-info,#motherSheet .order-info,#motherSheet .meta-line,.mother-sheet .ms-order-info,.mother-sheet .order-info,.mother-sheet .meta-line{font-family:var(--ms-family-header);font-size:var(--ms-subheader-size);font-weight:500;color:#444;margin:0 0 14px}
    #motherSheet section > h2,#motherSheet .ms-section-title,.mother-sheet section > h2,.mother-sheet .ms-section-title{font-family:var(--ms-family-header);font-size:calc(var(--ms-subheader-size) + 2px);font-weight:600;margin:20px 0 10px}
    #motherSheet table,.mother-sheet table{width:100%;border-collapse:collapse;font-size:var(--ms-body-size);line-height:var(--ms-body-line-height)}
    #motherSheet th,#motherSheet td,.mother-sheet th,.mother-sheet td{padding:calc(6px + var(--ms-row-spacing-adjust));border-bottom:1px solid #e5e7eb;text-align:left;vertical-align:top;font-family:var(--ms-family-rows)}
    #motherSheet th,.mother-sheet th{font-weight:600;color:#1f2937}
    #motherSheet tr:last-child td,.mother-sheet tr:last-child td{border-bottom:none}
    #motherSheet .ms-section,#motherSheet section,.mother-sheet .ms-section,.mother-sheet section{page-break-inside:avoid;break-inside:avoid}
    #motherSheet .ms-section + .ms-section,#motherSheet section + section,.mother-sheet .ms-section + .ms-section,.mother-sheet section + section{margin-top:18px}
    #motherSheet.font-system,.mother-sheet.font-system{--ms-family-base:var(--ms-sans-system);--ms-family-header:var(--ms-sans-system);--ms-family-rows:var(--ms-sans-system)}
    #motherSheet.font-inter,.mother-sheet.font-inter{--ms-family-base:var(--ms-inter-stack);--ms-family-header:var(--ms-inter-stack);--ms-family-rows:var(--ms-inter-stack)}
    #motherSheet.font-roboto,.mother-sheet.font-roboto{--ms-family-base:var(--ms-roboto-stack);--ms-family-header:var(--ms-roboto-stack);--ms-family-rows:var(--ms-roboto-stack)}
    #motherSheet.font-mono-rows td[data-column="position"],#motherSheet.font-mono-rows td[data-column="dimension"],#motherSheet.font-mono-rows td[data-column="dim"],#motherSheet.font-mono-rows td[data-col="pos"],#motherSheet.font-mono-rows td[data-col="dim"],#motherSheet.font-mono-rows td.pos,#motherSheet.font-mono-rows td.dimension,#motherSheet.font-mono-rows td.dim,.mother-sheet.font-mono-rows td[data-column="position"],.mother-sheet.font-mono-rows td[data-column="dimension"],.mother-sheet.font-mono-rows td[data-column="dim"],.mother-sheet.font-mono-rows td[data-col="pos"],.mother-sheet.font-mono-rows td[data-col="dim"],.mother-sheet.font-mono-rows td.pos,.mother-sheet.font-mono-rows td.dimension,.mother-sheet.font-mono-rows td.dim{font-family:var(--ms-mono-stack)}
    #motherSheet.density-compact,.mother-sheet.density-compact{--ms-row-spacing-adjust:-2px}
    #motherSheet.density-normal,.mother-sheet.density-normal{--ms-row-spacing-adjust:0px}
    #motherSheet.density-roomy,.mother-sheet.density-roomy{--ms-row-spacing-adjust:2px}
    #motherSheet.accent-thinrule section > h2,#motherSheet.accent-thinrule .ms-section-title,.mother-sheet.accent-thinrule section > h2,.mother-sheet.accent-thinrule .ms-section-title{border-bottom:1px solid #e9e9e9;padding-bottom:6px;margin-bottom:12px}
    #motherSheet.accent-leftbar section > h2,#motherSheet.accent-leftbar .ms-section-title,.mother-sheet.accent-leftbar section > h2,.mother-sheet.accent-leftbar .ms-section-title{border-left:2px solid var(--ms-accent-color);padding-left:10px;margin-left:-10px}
    #motherSheet.accent-leftbar section > h2:first-child,#motherSheet.accent-leftbar .ms-section-title:first-child,.mother-sheet.accent-leftbar section > h2:first-child,.mother-sheet.accent-leftbar .ms-section-title:first-child{margin-top:0}
    #motherSheet.accent-none section > h2,#motherSheet.accent-none .ms-section-title,.mother-sheet.accent-none section > h2,.mother-sheet.accent-none .ms-section-title{border:none;padding-left:0;padding-bottom:0;margin-left:0}
    #motherSheet .ms-summary,.mother-sheet .ms-summary{font-size:var(--ms-subheader-size);font-family:var(--ms-family-header);margin:0 0 12px}
    @media print{
      @page{margin:18mm}
      body{background:#fff}
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    @media (max-width:900px){
      table{min-width:520px}
      textarea{min-height:180px}
      .processing-layout{grid-template-columns:1fr;}
      .processing-controls .card{order:-1}
      .processing-order-list{max-height:none}
    }
    @media (max-width:600px){
      main.app{padding:18px 12px 36px}
      .tab-bar{flex-direction:column}
      .tab-bar button{width:100%}
      .controls,.filter-actions,.history-detail-actions{flex-direction:column;align-items:stretch}
      .history-pagination{flex-direction:column;align-items:stretch}
      .dropzone{padding:20px}
      th,td{font-size:13px}
    }
  </style>
  <style>
    /* Mother Sheet typography */
    #motherSheet, .mother-sheet {
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 14px;
      line-height: 1.6;
    }
    #motherSheet .ms-title, .mother-sheet .ms-title {
      font-size: 22px;
      font-weight: 700;
      line-height: 1.3;
      letter-spacing: 0.2px;
    }
    #motherSheet .ms-group-title, .mother-sheet .ms-group-title {
      font-size: 20px;
      font-weight: 700;
      line-height: 1.4;
      margin: 16px 0 6px;
    }
    #motherSheet .ms-row, .mother-sheet .ms-row {
      font-feature-settings: "tnum" 1, "liga" 0;
    }
    @media print {
      #motherSheet, .mother-sheet {
        font-size: 14px;
        line-height: 1.6;
      }
      #motherSheet .ms-title, .mother-sheet .ms-title {
        font-size: 22px;
      }
      #motherSheet .ms-group-title, .mother-sheet .ms-group-title {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="app-header">
      <h1>Order Extractor — Local</h1>
      <p class="muted">Paste the text you copied from the PDF, then click Extract.</p>
    </header>

    <div id="saveToast" class="toast" hidden>
      <span id="saveToastMessage"></span>
      <button id="saveToastView" class="link-button">View</button>
      <button id="saveToastDismiss" class="link-button muted" title="Dismiss">×</button>
    </div>

    <nav class="tab-bar">
      <button class="tab active" data-tab="extract">Dashboard</button>
      <button class="tab" data-tab="history">History</button>
      <button class="tab" data-tab="processing">Processing</button>
      <button class="tab" data-tab="labels">Labels</button>
      <button class="tab" data-tab="analysis">Analysis</button>
    </nav>

    <section id="tabExtract" class="tab-panel active">
      <div class="card">
        <label for="input" class="muted small" style="display:block;margin-bottom:6px;font-weight:600">Order text</label>
        <textarea id="input" placeholder="Paste order text here…"></textarea>
      </div>

      <div class="card">
        <div class="controls">
          <button id="extract" class="btn primary">Extract</button>
          <button id="rerun" class="btn" disabled>Re-run</button>
          <button id="approveSave" class="btn success" disabled>Approve & Save</button>
          <button id="copyCsv" class="btn">Copy CSV</button>
          <button id="downloadCsv" class="btn">Download CSV</button>
          <button id="printLabels" class="btn">Print Labels</button>
          <label class="inline-toggle">
            <input type="checkbox" data-group-toggle id="groupToggle" disabled>
            <span>Group identical sizes</span>
          </label>
          <details id="logoPanel">
            <summary>Logos</summary>
            <div style="display:flex;gap:12px;align-items:center;margin-top:8px;flex-wrap:wrap">
              <label>logokeli.png <input type="file" id="logoKeli" accept="image/png" /></label>
              <label>ce.png <input type="file" id="logoCe" accept="image/png" /></label>
              <span class="muted small" id="logoStatus"></span>
            </div>
            <div class="muted small" style="margin-top:6px">Tip: place <code>logokeli.png</code> / <code>ce.png</code> alongside this file or in <code>assets/</code>. These pickers store logos locally (browser only).</div>
          </details>
        </div>

        <div id="pdfDropZone" class="dropzone">Drop PDF here or click to upload.</div>
        <div class="status-row">
          <span id="status" class="muted small"></span>
          <span id="orderInfo" class="muted small"></span>
        </div>
        <div id="declaredBanner" class="warning-list" hidden></div>
        <div id="extractWarnings" class="warning-list" hidden>
          <h4>Warnings</h4>
          <ul></ul>
        </div>
        <div id="summary" class="summary"></div>
        <div style="margin-bottom:12px"><button type="button" id="fixAllAreas" class="btn small" hidden>Fix all areas</button></div>
        <div class="table-responsive" id="tableWrap"></div>
        <div class="notes-field">
          <label for="extractNotes" class="muted small">Approval notes (optional)</label>
          <textarea id="extractNotes" placeholder="Add a note before approving…"></textarea>
        </div>
        <div id="error" class="alert" hidden></div>
      </div>
    </section>

    <section id="tabHistory" class="tab-panel">
      <div class="card history-filters">
        <div class="filters-grid">
          <label>
            <span>Search</span>
            <input type="search" id="historySearch" placeholder="Client or order number" />
          </label>
          <label>
            <span>Status</span>
            <select id="historyStatusFilter">
              <option value="">All</option>
              <option value="draft">Draft</option>
              <option value="approved">Approved</option>
            </select>
          </label>
          <label>
            <span>Page size</span>
            <select id="historyLimit">
              <option value="10">10</option>
              <option value="25" selected>25</option>
              <option value="50">50</option>
            </select>
          </label>
          <div class="filter-actions">
            <button class="btn small" id="historyRefresh">Refresh</button>
            <button class="btn small" id="historyDownloadAll">Export CSV</button>
            <span id="historyOfflineBadge" class="badge offline" hidden>Offline cache</span>
          </div>
        </div>
        <div id="historyStatus" class="muted small" style="margin-top:10px"></div>
      </div>

      <div class="card">
        <div class="table-responsive" id="historyListWrap"></div>
        <div class="history-pagination">
          <button class="btn small" id="historyPrev">Previous</button>
          <div class="muted small">Page <span id="historyPage">1</span></div>
          <button class="btn small" id="historyNext">Next</button>
        </div>
      </div>

      <div class="card history-detail" id="historyDetailCard">
        <div class="history-detail-header">
          <div>
            <h2>Order Detail</h2>
            <div id="historyMeta" class="muted small"></div>
          </div>
          <div class="history-detail-actions">
            <button class="btn success" id="historyApprove" disabled>Approve & Save</button>
            <button class="btn small" id="historyProcessing" disabled>Send to Processing</button>
            <button class="btn small" id="historyPrint" disabled>Print Labels</button>
            <button class="btn small" id="historyCsv" disabled>Download CSV</button>
          </div>
        </div>
        <div class="history-detail-subheader">
          <div class="muted small">Grouping toggle applies to both Extract and History views.</div>
          <label class="inline-toggle">
            <input type="checkbox" data-group-toggle id="historyGroupToggle">
            <span>Group identical sizes</span>
          </label>
        </div>
        <div id="historyOrderInfo" class="muted small"></div>
        <div id="historyDeclaredBanner" class="warning-list" hidden></div>
        <div id="historyWarnings" class="warning-list" hidden>
          <h4>Warnings</h4>
          <ul></ul>
        </div>
        <div id="historySummary" class="summary"></div>
        <div style="margin-bottom:12px"><button type="button" id="historyFixAllAreas" class="btn small" hidden>Fix all areas</button></div>
        <div class="table-responsive" id="historyTableWrap"></div>
        <div class="notes-field">
          <label for="historyNotes" class="muted small">Approval notes (optional)</label>
          <textarea id="historyNotes" placeholder="Add a note before approving…"></textarea>
        </div>
        <div id="historyDetailEmpty" class="history-empty">Select an order from the list to view details.</div>
      </div>
    </section>

    <section id="tabProcessing" class="tab-panel">
      <div class="processing-layout">
        <div class="card processing-sidebar">
          <div>
            <h2 style="margin:0 0 4px">Processing</h2>
            <p class="muted small" style="margin:0">Send approved orders from History to build a combined Mother Sheet.</p>
          </div>
          <div id="processingOrderList" class="processing-order-list processing-empty">No orders added yet.</div>
          <button id="processingClear" class="btn danger" disabled>Clear Sheet</button>
        </div>
        <div class="card processing-main">
          <div id="processingMeta" class="processing-meta">
            <span>Mother Sheet – Client: — | Orders: — | Date: —</span>
            <span class="muted small">Rows: 0</span>
          </div>
          <div class="muted small" style="margin:8px 0 6px;display:flex;align-items:center;gap:8px">
            <label class="inline-toggle">
              <input type="checkbox" id="processingWysiwygToggle">
              <span>Live HTML preview (WYSIWYG)</span>
            </label>
          </div>
          <div id="motherSheetPreview" class="mother-sheet" hidden></div>
          <div id="processingPreview" class="processing-preview">No orders added yet.</div>
        </div>
        <div class="processing-controls">
          <div class="card">
            <h3 style="margin:0 0 8px">Options</h3>
            <label class="toggle-row">
              <span>Restart numbering per group</span>
              <input type="checkbox" id="processingRestartToggle">
            </label>
            <label class="toggle-row">
              <span>Normalize LP → G</span>
              <input type="checkbox" id="processingNormalizeToggle" checked>
            </label>
            <label class="toggle-row">
              <span>Decimal separator</span>
              <select id="processingDecimalSelect">
                <option value="comma" selected>Comma (,)</option>
                <option value="dot">Dot (.)</option>
              </select>
            </label>
            <label class="toggle-row">
              <span>Merge across orders</span>
              <input type="checkbox" id="processingMergeOrdersToggle">
            </label>
            <label class="toggle-row">
              <span>Auto-apply Danko rounding</span>
              <input type="checkbox" id="processingAutoDankoToggle">
            </label>
          </div>
          <div class="card processing-header-editor">
            <h3 style="margin:0">Header Editor</h3>
            <select id="processingHeaderSelect"></select>
            <input type="text" id="processingHeaderInput" placeholder="Display header text…" />
            <div class="processing-header-actions" style="display:flex;gap:8px">
              <button class="btn small" id="processingHeaderApply">Apply</button>
              <button class="btn small muted" id="processingHeaderReset">Reset</button>
            </div>
            <p class="processing-warning" id="processingHeaderHint" hidden></p>
          </div>
      <div class="card processing-actions">
        <button class="btn" id="processingRoundingToggle">Apply Danko Rounding</button>
        <button class="btn" id="processingGroup">Group Dimensions</button>
        <button class="btn" id="processingCopy">Copy Text</button>
        <button class="btn" id="processingExportPdf">Export PDF</button>
        <button class="btn" id="processingExportCsv">Export CSV</button>
        <div id="processingRoundingStatus" class="muted small"></div>
      </div>
        </div>
      </div>
    </section>

    <section id="tabLabels" class="tab-panel">
      <div class="card">
        <h2 style="margin-top:0">Labels</h2>
        <p class="muted small">Build reusable label jobs from your current extract or selected history order, then download PDFs when you’re ready to print.</p>
        <div class="labels-controls">
          <button class="btn small" id="labelsFromProcessing">Add from Processing</button>
          <button class="btn small" id="labelsFromProcessingDownload">Add & Download</button>
          <button class="btn small" id="labelsFromHistory">Add selected history order</button>
          <button class="btn small muted" id="labelsClear" disabled>Clear jobs</button>
        </div>
        <div class="labels-summary" id="labelsSummary"></div>
        <div id="labelsStatus" class="muted small"></div>
        <p class="muted small" style="margin-top:12px">Tip: use the Logos picker in Dashboard to store <code>logokeli.png</code> and <code>ce.png</code> locally. They’ll be embedded automatically in label PDFs.</p>
      </div>
      <div class="card">
        <div class="table-responsive" id="labelsJobsWrap">
          <div class="labels-empty">No label jobs yet. Use the buttons above to add one.</div>
        </div>
      </div>
    </section>

    <section id="tabAnalysis" class="tab-panel">
      <div class="card">
        <h2 style="margin-top:0">Analysis</h2>
        <p class="muted small">AI-assisted analytics on your orders.</p>
        <div class="status-row">
          <span id="analysisStatus" class="muted small"></span>
        </div>
        <button type="button" class="btn small" id="analysisDebugToggle" style="display:none;margin-top:8px">Log dataset rows</button>
      </div>

      <div class="card" id="analysisKpisCard">
        <h3 style="margin-top:0">KPIs</h3>
        <div class="summary" id="analysisKpis">
          <span class="pill"><span class="muted small">Orders</span><strong id="analysisKpiOrders">0</strong></span>
          <span class="pill"><span class="muted small">Units</span><strong id="analysisKpiUnits">0</strong></span>
          <span class="pill"><span class="muted small">m²</span><strong id="analysisKpiArea">0</strong></span>
          <span class="pill"><span class="muted small">Avg m²/order</span><strong id="analysisKpiAvgArea">0</strong></span>
          <span class="pill"><span class="muted small">Avg units/order</span><strong id="analysisKpiAvgUnits">0</strong></span>
        </div>
      </div>

      <div class="card" id="analysisTopClientsCard">
        <h3 style="margin-top:0">Top Clients</h3>
        <div class="table-responsive">
          <table>
            <thead>
              <tr>
                <th>Client</th>
                <th>Orders</th>
                <th>Units</th>
                <th>Area (m²)</th>
              </tr>
            </thead>
            <tbody id="analysisTopClientsBody">
              <tr>
                <td colspan="4" class="muted">No data.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="card" id="analysisTopTypesCard">
        <h3 style="margin-top:0">Top Glass Types</h3>
        <div class="table-responsive">
          <table>
            <thead>
              <tr>
                <th>Type</th>
                <th>Lines</th>
                <th>Units</th>
              </tr>
            </thead>
            <tbody id="analysisTopTypesBody">
              <tr>
                <td colspan="3" class="muted">No data.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="card" id="analysisDimensionsCard">
        <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap">
          <h3 style="margin:0">Top Dimensions</h3>
          <div class="controls" style="margin:0" id="analysisDimensionControls">
            <label class="muted small" style="display:flex;flex-direction:column;gap:4px;min-width:120px">
              <span>Tolerance (±mm)</span>
              <input type="number" id="analysisTolerance" min="0" max="5" step="0.1" value="1" />
            </label>
            <label class="inline-toggle">
              <input type="checkbox" id="analysisOrientation" checked />
              <span>Orientation-agnostic</span>
            </label>
            <button type="button" class="btn small" id="analysisRecalc">Recalculate</button>
          </div>
        </div>
        <div class="table-responsive">
          <table>
            <thead>
              <tr>
                <th>Dimension</th>
                <th>Qty</th>
                <th>Orders</th>
                <th>Clients</th>
              </tr>
            </thead>
            <tbody id="analysisDimensionsBody">
              <tr>
                <td colspan="4" class="muted">No data.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="card" id="analysisAiCard">
        <h3 style="margin-top:0">AI Prompt</h3>
        <div class="controls" style="align-items:stretch">
          <input type="text" id="analysisQuestion" placeholder="e.g., Which client ordered the most units last month?" style="flex:1;min-width:200px;padding:8px 12px;border:1px solid var(--border-dark);border-radius:10px;background:#fbfcff" />
          <button type="button" class="btn primary" id="analysisAsk">Ask</button>
        </div>
        <div id="analysisAnswer" class="muted small" style="margin-top:12px">Ask a question to see AI insights.</div>
      </div>
    </section>
  </main>

  <input type="file" id="pdfInput" accept="application/pdf" hidden />

<script>
const API_BASE = "http://127.0.0.1:5055";
const HISTORY_CACHE_KEY = "loe.history.cache.v1";
const HISTORY_CACHE_LIMIT = 200;
const DEFAULT_APPEARANCE_SETTINGS = Object.freeze({
  headerFontSize: 20,
  orderInfoFontSize: 14,
  bodyFontSize: 12.5,
  fontFamily: "system-sans",
  rowDensity: "normal",
  accentStyle: "none",
});
const MOTHER_SHEET_SELECTOR = "#motherSheet, .mother-sheet";
const ANALYSIS_MAX_DATASET_CHARS = 50000;

// ✅ Danko Rounding: Global functions for Processing + Mother Sheet
window.dankoRound = function(valueMm) {
  if (!Number.isFinite(valueMm)) return valueMm;
  const lastDigit = valueMm % 10;
  if (lastDigit === 1 || lastDigit === 2) return valueMm - lastDigit;        // → 0
  if (lastDigit === 6 || lastDigit === 7) return valueMm - (lastDigit - 5);  // → 5
  if (lastDigit === 4) return valueMm + (5 - lastDigit);                     // → 5
  if (lastDigit === 9) return valueMm + (10 - lastDigit);                    // → next 0
  return valueMm; // keep unchanged
};

window.applyDankoRuleToDim = function(dimStr) {
  if (!dimStr || !/^\d+x\d+$/.test(dimStr)) {
    return { w: null, h: null, text: dimStr, changed: false };
  }
  const [w0, h0] = dimStr.split("x").map(n => parseInt(n, 10));
  const w = window.dankoRound(w0);
  const h = window.dankoRound(h0);
  const changed = (w !== w0) || (h !== h0);
  return { w, h, text: `${w}x${h}`, changed, original: `${w0}x${h0}` };
};

const renderTargets = {
  extract: { tableId: "tableWrap", summaryId: "summary", orderInfoId: "orderInfo" },
  history: { tableId: "historyTableWrap", summaryId: "historySummary", orderInfoId: "historyOrderInfo" }
};

const renderState = {
  extract: { rows: [], displayed: [] },
  history: { rows: [], displayed: [] }
};

let groupState = false;
let appearanceSettings = { ...DEFAULT_APPEARANCE_SETTINGS };
let motherSheetObserver = null;

setGlobalAppearanceVariables(appearanceSettings);
ensureMotherSheetObserver();

const historyState = {
  query: "",
  status: "",
  limit: 25,
  offset: 0,
  hasMore: false,
  items: [],
  selectedOrder: null,
  offline: false,
  loading: false,
  loadedOnce: false,
  loadingPromise: Promise.resolve(),
  needsRefresh: false
};

const appState = {
  extract: {
    rows: [],
    rowWarnings: {},
    warnings: [],
    draftId: null,
    status: "idle",
    savedOrderId: null,
    orderNumber: "",
    appliedCorrections: [],
    notes: "",
    declaredUnits: null,
    declaredArea: null,
    parsedUnits: 0,
    parsedArea: 0,
    nextRid: 0,
    client: "—",
  },
  historyDetail: {
    order: null,
    rows: [],
    rowWarnings: {},
    warnings: [],
    notes: "",
    declaredUnits: null,
    declaredArea: null,
    parsedUnits: 0,
    parsedArea: 0,
    nextRid: 0,
  },
  processing: {
    cart: [],
    rows: [],
    preview: { text: "", groups: [], meta: {} },
    grouped: false,
    options: {
      restartPerGroup: false,
      decimalSeparator: "comma",
      normalizeLPtoG: true,
      mergeAcrossOrders: false,
      autoDanko: false,
    },
    headerOverrides: {},
    rounding: {
      manualApplied: false,
      message: "",
    },
  },
  labels: {
    jobs: [],
    nextId: 1,
  },
};

const analysisState = {
  initialized: false,
  loading: false,
  dataset: null,
  metrics: null,
  topClients: [],
  topTypes: [],
  topDimensions: [],
  tolerance: 1,
  orientationAgnostic: true,
  promise: Promise.resolve(),
  sessionId: null,
  allOrdersCache: [],
  allOrdersPromise: null,
  allOrdersDirty: true,
  ai: {
    loading: false,
    lastQuestion: "",
  },
  orderRowCache: new Map(),
  orderRowRequests: new Map(),
};

const tabs = document.querySelectorAll(".tab-bar .tab");
const panels = {
  extract: document.getElementById("tabExtract"),
  history: document.getElementById("tabHistory"),
  processing: document.getElementById("tabProcessing"),
  labels: document.getElementById("tabLabels"),
  analysis: document.getElementById("tabAnalysis")
};

const saveToast = document.getElementById("saveToast");
const saveToastMessage = document.getElementById("saveToastMessage");
const saveToastView = document.getElementById("saveToastView");
const saveToastDismiss = document.getElementById("saveToastDismiss");
let saveToastTimer = null;

const statusEl = document.getElementById("status");
const errorEl = document.getElementById("error");
const historyStatusEl = document.getElementById("historyStatus");
const historyOfflineBadge = document.getElementById("historyOfflineBadge");
const historyPageEl = document.getElementById("historyPage");
const historyDetailEmpty = document.getElementById("historyDetailEmpty");
const historyPrintBtn = document.getElementById("historyPrint");
const historyCsvBtn = document.getElementById("historyCsv");
const historyMetaEl = document.getElementById("historyMeta");
const historyProcessingBtn = document.getElementById("historyProcessing");
const processingOrderList = document.getElementById("processingOrderList");
const processingMetaEl = document.getElementById("processingMeta");
const processingPreviewEl = document.getElementById("processingPreview");
const processingClearBtn = document.getElementById("processingClear");
const processingRestartToggle = document.getElementById("processingRestartToggle");
const processingNormalizeToggle = document.getElementById("processingNormalizeToggle");
const processingDecimalSelect = document.getElementById("processingDecimalSelect");
const processingMergeOrdersToggle = document.getElementById("processingMergeOrdersToggle");
const processingHeaderSelect = document.getElementById("processingHeaderSelect");
const processingHeaderInput = document.getElementById("processingHeaderInput");
const processingHeaderApply = document.getElementById("processingHeaderApply");
const processingHeaderReset = document.getElementById("processingHeaderReset");
const processingHeaderHint = document.getElementById("processingHeaderHint");
const processingRoundingBtn = document.getElementById("processingRoundingToggle");
const processingGroupBtn = document.getElementById("processingGroup");
const processingCopyBtn = document.getElementById("processingCopy");
const processingExportPdfBtn = document.getElementById("processingExportPdf");
const processingExportCsvBtn = document.getElementById("processingExportCsv");
const processingRoundingStatus = document.getElementById("processingRoundingStatus");
const processingAutoDankoToggle = document.getElementById("processingAutoDankoToggle");
const labelsJobsWrap = document.getElementById("labelsJobsWrap");
const labelsSummaryEl = document.getElementById("labelsSummary");
const labelsStatusEl = document.getElementById("labelsStatus");
const labelsFromProcessingBtn = document.getElementById("labelsFromProcessing");
const labelsFromProcessingDownloadBtn = document.getElementById("labelsFromProcessingDownload");
const labelsFromHistoryBtn = document.getElementById("labelsFromHistory");
const labelsClearBtn = document.getElementById("labelsClear");
const analysisStatusEl = document.getElementById("analysisStatus");
const analysisKpiOrdersEl = document.getElementById("analysisKpiOrders");
const analysisKpiUnitsEl = document.getElementById("analysisKpiUnits");
const analysisKpiAreaEl = document.getElementById("analysisKpiArea");
const analysisKpiAvgAreaEl = document.getElementById("analysisKpiAvgArea");
const analysisKpiAvgUnitsEl = document.getElementById("analysisKpiAvgUnits");
const analysisTopClientsBody = document.getElementById("analysisTopClientsBody");
const analysisTopTypesBody = document.getElementById("analysisTopTypesBody");
const analysisDimensionsBody = document.getElementById("analysisDimensionsBody");
const analysisToleranceInput = document.getElementById("analysisTolerance");
const analysisOrientationToggle = document.getElementById("analysisOrientation");
const analysisRecalcBtn = document.getElementById("analysisRecalc");
const analysisQuestionInput = document.getElementById("analysisQuestion");
const analysisAskBtn = document.getElementById("analysisAsk");
const analysisAnswerEl = document.getElementById("analysisAnswer");
const analysisDebugToggle = document.getElementById("analysisDebugToggle");
const wysiwygToggle = document.getElementById("processingWysiwygToggle");
const wysiwygPreview = document.getElementById("motherSheetPreview");

const groupToggles = document.querySelectorAll("[data-group-toggle]");

function activateTab(name){
  tabs.forEach(btn => {
    const isTarget = btn.dataset.tab === name;
    btn.classList.toggle("active", isTarget);
  });
  Object.entries(panels).forEach(([key, panel])=>{
    panel.classList.toggle("active", key === name);
  });
  if (name === "history"){
    ensureHistoryLoaded();
  }else if (name === "processing"){
    ensureHistoryLoaded();
    rebuildProcessingRows();
    updateProcessingUI();
  }else if (name === "analysis"){
    ensureAnalysisReady();
    if (analysisState.initialized && analysisState.allOrdersDirty){
      refreshAnalysis();
    }
  }else if (name === "labels"){
    updateLabelsUI();
  }
}

tabs.forEach(btn=>{
  btn.addEventListener("click", ()=> activateTab(btn.dataset.tab));
});

function showSavedToast(orderId){
  if (!orderId) return;
  saveToast.dataset.orderId = orderId;
  saveToastMessage.textContent = `Saved as #${orderId}`;
  saveToast.hidden = false;
  clearTimeout(saveToastTimer);
  saveToastTimer = setTimeout(()=> hideSavedToast(), 6000);
}

function hideSavedToast(){
  saveToast.hidden = true;
  saveToastMessage.textContent = "";
  delete saveToast.dataset.orderId;
}

saveToastDismiss.addEventListener("click", hideSavedToast);
saveToastView.addEventListener("click", ()=>{
  const id = Number(saveToast.dataset.orderId);
  if (!id) return;
  hideSavedToast();
  activateTab("history");
  ensureHistoryLoaded().then(()=> openOrderFromList(id));
});

function setGroupState(value){
  groupState = !!value;
  groupToggles.forEach(toggle => {
    if (toggle.checked !== groupState){
      toggle.checked = groupState;
    }
  });
  updateExtractUI();
  updateHistoryDetailUI();
}

groupToggles.forEach(toggle=>{
  toggle.addEventListener("change", (event)=> setGroupState(event.target.checked));
});

setGroupState(false);

function clampNumber(value, min, max, fallback){
  const num = Number(value);
  if (!Number.isFinite(num)) return fallback;
  return Math.min(Math.max(num, min), max);
}

function setAnalysisStatus(message){
  if (analysisStatusEl){
    analysisStatusEl.textContent = message || "";
  }
}

function pickFirstString(values, fallback = ""){
  if (values == null) return fallback;
  if (!Array.isArray(values)){
    const str = String(values).trim();
    return str || fallback;
  }
  for (const value of values){
    if (Array.isArray(value)){
      const nested = pickFirstString(value);
      if (nested) return nested;
    }else if (value != null){
      const str = String(value).trim();
      if (str) return str;
    }
  }
  return fallback;
}

function pickFirstNumber(values){
  if (values == null) return null;
  if (!Array.isArray(values)){
    const numeric = typeof values === "string" ? values.replace(",", ".") : values;
    const num = Number(numeric);
    return Number.isFinite(num) ? num : null;
  }
  for (const value of values){
    if (Array.isArray(value)){
      const nested = pickFirstNumber(value);
      if (nested != null) return nested;
    }else if (value != null && value !== ""){
      const normalized = typeof value === "string" ? value.replace(",", ".") : value;
      const num = Number(normalized);
      if (Number.isFinite(num)) return num;
    }
  }
  return null;
}

function findNumeric(values){
  if (values == null) return null;
  if (!Array.isArray(values)){
    return normalizeDimensionNumber(values);
  }
  for (const value of values){
    if (Array.isArray(value)){
      const nested = findNumeric(value);
      if (nested != null) return nested;
    }else{
      const parsed = normalizeDimensionNumber(value);
      if (parsed != null) return parsed;
    }
  }
  return null;
}

function extractOrderDate(order){
  if (!order || typeof order !== "object") return null;
  const candidates = [
    order.created_at,
    order.createdAt,
    order.created,
    order.inserted_at,
    order.insertedAt,
    order.timestamp,
    order.date,
  ];
  for (const candidate of candidates){
    if (candidate == null || candidate === "") continue;
    if (typeof candidate === "number"){
      const date = new Date(candidate);
      if (!Number.isNaN(date.getTime())) return date;
      continue;
    }
    const str = String(candidate).trim();
    if (!str) continue;
    const date = new Date(str);
    if (!Number.isNaN(date.getTime())) return date;
  }
  return null;
}

function getOrderLabel(order){
  if (!order) return "—";
  const numbers = Array.isArray(order.order_numbers)
    ? order.order_numbers.map(value => value == null ? "" : String(value).trim()).filter(Boolean)
    : [];
  if (numbers.length){
    return numbers.join(", ");
  }
  const fallback = pickFirstString([
    order.order_number,
    order.orderNumber,
    order.order_no,
    order.orderNo,
    order.order,
    order.orderId,
    order.order_id,
    order.id,
  ]);
  if (fallback){
    return fallback;
  }
  return order.id != null ? `#${order.id}` : "—";
}

function computeRowArea(row){
  if (!row) return 0;
  const directArea = pickFirstNumber([
    row.area,
    row.area_m2,
    row.areaM2,
    row.computed_area,
    row.computedArea,
  ]);
  if (directArea != null) return directArea;
  let width = normalizeDimensionNumber(row.width);
  let height = normalizeDimensionNumber(row.height);
  if (width == null || height == null){
    const dimensionLabel = pickFirstString([
      row.dimension,
      row.dimension_display,
      row.dim,
      row.dimensionDisplay,
    ]);
    if (dimensionLabel){
      const parsed = parseDimensionTokens(dimensionLabel);
      if (width == null && parsed.width != null) width = parsed.width;
      if (height == null && parsed.height != null) height = parsed.height;
    }
  }
  if (width != null && height != null){
    return (width * height) / 1000000;
  }
  return 0;
}

function mapRowForAnalysis(row, orderLabel, clientLabel){
  if (!row) return null;
  const dimensionDisplay = pickFirstString([
    row.dimension,
    row.dimension_display,
    row.dim,
    row.dimensionDisplay,
  ]);
  let width = findNumeric([
    row.width,
    row.width_mm,
    row.width_mm_calc,
    row.widthValue,
    row.widthNumeric,
  ]);
  let height = findNumeric([
    row.height,
    row.height_mm,
    row.height_mm_calc,
    row.heightValue,
    row.heightNumeric,
  ]);
  let widthDisplay = pickFirstString([
    row.width_display,
    row.widthDisplay,
    row.width_text,
  ]);
  let heightDisplay = pickFirstString([
    row.height_display,
    row.heightDisplay,
    row.height_text,
  ]);
  if ((width == null || height == null) && dimensionDisplay){
    const parsed = parseDimensionTokens(dimensionDisplay);
    if (width == null && parsed.width != null) width = parsed.width;
    if (height == null && parsed.height != null) height = parsed.height;
    if (!widthDisplay && parsed.widthDisplay) widthDisplay = parsed.widthDisplay;
    if (!heightDisplay && parsed.heightDisplay) heightDisplay = parsed.heightDisplay;
  }
  if (!widthDisplay && width != null){
    widthDisplay = String(width);
  }
  if (!heightDisplay && height != null){
    heightDisplay = String(height);
  }
  const qty = Math.max(0, pickFirstNumber([
    row.quantity,
    row.qty,
    row.Qty,
    row.QTY,
    row.qty_total,
    row.total_qty,
    row.quantity_total,
    row.qtyTotal,
  ]) || 0);
  const type = pickFirstString([
    row.type,
    row.composition_raw,
    row.composition,
    row.composition_display,
    row.glass_type,
    row.glassType,
    row.description,
  ], "");
  const widthNumeric = Number.isFinite(width) ? width : null;
  const heightNumeric = Number.isFinite(height) ? height : null;
  const widthDisplayValue = (() => {
    const display = widthDisplay != null ? String(widthDisplay).trim() : "";
    if (display) return display;
    return widthNumeric != null ? String(widthNumeric) : null;
  })();
  const heightDisplayValue = (() => {
    const display = heightDisplay != null ? String(heightDisplay).trim() : "";
    if (display) return display;
    return heightNumeric != null ? String(heightNumeric) : null;
  })();
  const orderIdValue = orderLabel && orderLabel.trim().length ? orderLabel.trim() : "—";
  const clientValue = clientLabel && clientLabel.trim().length ? clientLabel.trim() : "—";
  const dimensionLabel = dimensionDisplay && dimensionDisplay.trim().length ? dimensionDisplay.trim() : null;
  return {
    type,
    width: widthNumeric,
    height: heightNumeric,
    widthDisplay: widthDisplayValue,
    heightDisplay: heightDisplayValue,
    qty,
    orderId: orderIdValue,
    client: clientValue,
    dimensionDisplay: dimensionLabel,
  };
}

function cloneRowArray(rows){
  return Array.isArray(rows) ? rows.map(item => ({ ...item })) : [];
}

async function resolveOrderRowsForAnalysis(order){
  if (!order || order.id == null){
    return [];
  }
  if (Array.isArray(order.rows) && order.rows.length){
    analysisState.orderRowCache.set(order.id, cloneRowArray(order.rows));
    return cloneRowArray(order.rows);
  }
  if (analysisState.orderRowCache.has(order.id)){
    return cloneRowArray(analysisState.orderRowCache.get(order.id));
  }
  if (analysisState.orderRowRequests.has(order.id)){
    const pending = await analysisState.orderRowRequests.get(order.id);
    return cloneRowArray(pending);
  }
  const fetchPromise = (async ()=>{
    try{
      const detail = await fetchOrder(order.id);
      if (detail && Array.isArray(detail.rows) && detail.rows.length){
        analysisState.orderRowCache.set(order.id, cloneRowArray(detail.rows));
        return cloneRowArray(detail.rows);
      }
    }catch(error){
      console.warn("Analysis: failed to fetch order rows", error);
    }
    const cachedItems = readHistoryCache();
    const cachedOrder = cachedItems.find(item => item && item.id === order.id);
    if (cachedOrder && Array.isArray(cachedOrder.rows) && cachedOrder.rows.length){
      analysisState.orderRowCache.set(order.id, cloneRowArray(cachedOrder.rows));
      return cloneRowArray(cachedOrder.rows);
    }
    return [];
  })();
  analysisState.orderRowRequests.set(order.id, fetchPromise);
  try{
    const result = await fetchPromise;
    return cloneRowArray(result);
  }finally{
    analysisState.orderRowRequests.delete(order.id);
  }
}

async function mapHistoryOrderForAnalysis(order){
  const orderLabel = getOrderLabel(order);
  const client = pickFirstString([
    order.client,
    order.client_hint,
    order.client_name,
    order.clientName,
    order.customer,
  ], "—");
  const createdAt = pickFirstString([
    order.created_at,
    order.createdAt,
    order.created,
  ]) || null;
  const parsedUnits = pickFirstNumber([
    order.parsed_units,
    order.units_total,
    order.total_units,
    order.units,
  ]) || 0;
  const parsedArea = pickFirstNumber([
    order.parsed_area,
    order.area_total,
    order.total_area,
    order.area,
  ]) || 0;
  const orderRows = await resolveOrderRowsForAnalysis(order);
  const rows = orderRows
    .map(row => mapRowForAnalysis(row, orderLabel, client))
    .filter(Boolean);
  return {
    id: order.id,
    order_numbers: Array.isArray(order.order_numbers)
      ? order.order_numbers
      : (orderLabel && orderLabel !== "—"
        ? orderLabel.split(/\s*,\s*/).map(token => token.trim()).filter(Boolean)
        : []),
    order_number: pickFirstString([order.order_number, order.orderNumber]) || undefined,
    client,
    created_at: createdAt,
    parsed_units: parsedUnits,
    parsed_area: parsedArea,
    rows,
  };
}

function mapProcessingOrderForAnalysis(entry){
  if (!entry) return null;
  const label = entry.orderLabel || getOrderLabel(entry);
  const client = pickFirstString([
    entry.client,
    entry.client_label,
    entry.clientLabel,
  ], "—");
  const rows = Array.isArray(entry.rows)
    ? entry.rows.map(row => mapRowForAnalysis(row, label, client)).filter(Boolean)
    : [];
  const units = rows.reduce((sum, row)=> sum + (Number(row.qty) || 0), 0);
  const area = rows.reduce((sum, row)=> sum + computeRowArea(row), 0);
  const orderNumbers = label ? label.split(/\s*,\s*/).map(token => token.trim()).filter(Boolean) : [];
  return {
    id: entry.id ?? label,
    order_numbers: orderNumbers,
    order_number: orderNumbers.length === 1 ? orderNumbers[0] : undefined,
    client,
    created_at: entry.createdAt || null,
    parsed_units: units,
    parsed_area: area,
    rows,
  };
}

function sortOrdersNewestFirst(items){
  const list = Array.isArray(items) ? items.slice() : [];
  return list.sort((a, b)=>{
    const da = extractOrderDate(a);
    const db = extractOrderDate(b);
    const ta = da ? da.getTime() : 0;
    const tb = db ? db.getTime() : 0;
    return tb - ta;
  });
}

async function fetchAllApprovedOrders(){
  if (!analysisState.allOrdersDirty && Array.isArray(analysisState.allOrdersCache)){
    return analysisState.allOrdersCache.slice();
  }
  if (analysisState.allOrdersPromise){
    const cached = await analysisState.allOrdersPromise;
    return cached.slice();
  }
  const task = (async ()=>{
    const aggregated = [];
    let offset = 0;
    const limit = 100;
    let hasMore = true;
    while (hasMore){
      const params = { limit, offset, status: "approved" };
      let data;
      try{
        data = await fetchOrders(params);
      }catch(error){
        console.warn("Analysis: failed to fetch all orders batch", error);
        break;
      }
      const items = Array.isArray(data?.items) ? data.items : [];
      aggregated.push(...items);
      hasMore = !!data?.has_more && items.length > 0;
      offset += limit;
      if (!hasMore){
        break;
      }
    }
    analysisState.allOrdersCache = aggregated;
    analysisState.allOrdersDirty = false;
    return aggregated.slice();
  })();
  analysisState.allOrdersPromise = task.finally(()=>{
    analysisState.allOrdersPromise = null;
  });
  return task;
}

async function buildAllTimeAnalysisDataset(options = {}){
  const tolerance = options.tolerance;
  const orientationAgnostic = options.orientationAgnostic;
  let approvedOrders = [];
  try{
    approvedOrders = await fetchAllApprovedOrders();
  }catch(error){
    console.warn("Analysis: unable to load all orders", error);
    approvedOrders = [];
  }
  const sortedAll = sortOrdersNewestFirst(approvedOrders);
  const orders = [];
  for (const order of sortedAll){
    orders.push(await mapHistoryOrderForAnalysis(order));
  }
  const processingOrders = Array.isArray(appState.processing.cart)
    ? appState.processing.cart.map(mapProcessingOrderForAnalysis).filter(Boolean)
    : [];
  const aggregates = computeAggregatesForAllTime(orders, processingOrders, {
    tolerance,
    orientationAgnostic,
  });
  return {
    scope: "all-time",
    orders,
    processing_orders: processingOrders,
    aggregates,
    meta: { truncated: false, notes: [] },
  };
}

function mergeOrdersForAnalysis(dataset){
  if (!dataset) return [];
  const base = Array.isArray(dataset.orders) ? dataset.orders.map(order => JSON.parse(JSON.stringify(order))) : [];
  if (Array.isArray(dataset.processing_orders)){
    dataset.processing_orders.forEach(order => {
      base.push(JSON.parse(JSON.stringify(order)));
    });
  }
  return base;
}

function collectAnalysisRows(orders){
  const rows = [];
  orders.forEach(order => {
    if (!order || !Array.isArray(order.rows)) return;
    order.rows.forEach(row => {
      if (row) rows.push({ ...row });
    });
  });
  return rows;
}

function getOrderTimestampForAnalysis(order){
  if (!order) return 0;
  const created = order.created_at || order.createdAt || null;
  if (created){
    const date = new Date(created);
    if (!Number.isNaN(date.getTime())) return date.getTime();
  }
  return 0;
}

function computeAggregatesForAllTime(orders, processing, options){
  const tolerance = Number(options?.tolerance) || 0;
  const orientationAgnostic = !!options?.orientationAgnostic;
  const totals = { orders: (orders?.length || 0) + (processing?.length || 0), units: 0, area_m2: 0 };
  const byClientMap = new Map();
  const byTypeMap = new Map();
  const dimensionRows = [];
  const recentRows = [];

  function addClientSample(order, units, area){
    const clientName = (order.client || "—").trim() || "—";
    if (!byClientMap.has(clientName)){
      byClientMap.set(clientName, {
        client: clientName,
        units: 0,
        area: 0,
        orders: new Set(),
      });
    }
    const entry = byClientMap.get(clientName);
    entry.units += units;
    entry.area += area;
    const orderKey = order.id != null ? String(order.id) : (Array.isArray(order.order_numbers) && order.order_numbers.length ? order.order_numbers.join("|") : order.order_number || order.orderId || Math.random().toString(16).slice(2));
    entry.orders.add(orderKey);
  }

  function foldOrder(order){
    if (!order || !Array.isArray(order.rows)) return;
    let orderUnits = 0;
    let orderArea = 0;
    order.rows.forEach(row => {
      if (!row) return;
      const qty = Number(row.qty) || 0;
      orderUnits += qty;
      const area = computeRowArea(row);
      orderArea += area;
      const typeKey = (row.type || "—").trim() || "—";
      if (!byTypeMap.has(typeKey)){
        byTypeMap.set(typeKey, { type: typeKey, lines: 0, units: 0, area: 0 });
      }
      const typeEntry = byTypeMap.get(typeKey);
      typeEntry.lines += 1;
      typeEntry.units += qty;
      typeEntry.area += area;
      dimensionRows.push({ ...row, orderId: row.orderId || getOrderLabel(order), client: row.client || order.client || "—" });
      recentRows.push({
        orderId: row.orderId || getOrderLabel(order),
        client: row.client || order.client || "—",
        type: row.type || "",
        width: row.width ?? null,
        height: row.height ?? null,
        widthDisplay: row.widthDisplay || null,
        heightDisplay: row.heightDisplay || null,
        qty,
        created_at: order.created_at || null,
      });
    });
    totals.units += orderUnits;
    totals.area_m2 += orderArea;
    addClientSample(order, orderUnits, orderArea);
  }

  (orders || []).forEach(foldOrder);
  (processing || []).forEach(foldOrder);

  const by_client = Array.from(byClientMap.values()).map(entry => ({
    client: entry.client,
    orders: entry.orders.size,
    units: entry.units,
    area_m2: Number(entry.area.toFixed(3)),
  })).sort((a, b)=>{
    if (b.area_m2 !== a.area_m2) return b.area_m2 - a.area_m2;
    return a.client.localeCompare(b.client);
  }).slice(0, 25);

  const by_type = Array.from(byTypeMap.values()).map(entry => ({
    type: entry.type,
    lines: entry.lines,
    units: entry.units,
    area_m2: Number(entry.area.toFixed(3)),
  })).sort((a, b)=>{
    if (b.units !== a.units) return b.units - a.units;
    return a.type.localeCompare(b.type);
  }).slice(0, 25);

  const dimBuckets = buildDimensionBuckets(dimensionRows, tolerance, orientationAgnostic).map(bucket => ({
    dim: bucket.dimension,
    qty: bucket.qty,
    orders: bucket.orders,
    clients: bucket.clients,
  }));

  recentRows.sort((a, b)=>{
    const ta = a.created_at ? new Date(a.created_at).getTime() : 0;
    const tb = b.created_at ? new Date(b.created_at).getTime() : 0;
    return tb - ta;
  });

  return {
    totals: {
      orders: totals.orders,
      units: totals.units,
      area_m2: Number(totals.area_m2.toFixed(3)),
    },
    by_client,
    by_type,
    by_dim: dimBuckets,
    recent_samples: recentRows.slice(0, 50),
  };
}

function prepareDatasetForTransmission(dataset, options){
  const ordersSource = Array.isArray(dataset?.orders) ? dataset.orders : [];
  const processingSource = Array.isArray(dataset?.processing_orders) ? dataset.processing_orders : [];
  const aggregates = dataset?.aggregates
    ? JSON.parse(JSON.stringify(dataset.aggregates))
    : computeAggregatesForAllTime(ordersSource, processingSource, {
        tolerance: options?.tolerance,
        orientationAgnostic: options?.orientationAgnostic,
      });
  const payloadMeta = {
    truncated: !!(dataset?.meta && dataset.meta.truncated),
    notes: Array.isArray(dataset?.meta?.notes) ? dataset.meta.notes.slice() : [],
  };
  const payload = {
    scope: dataset?.scope || "all-time",
    meta: payloadMeta,
    aggregates,
    orders: ordersSource.map(order => JSON.parse(JSON.stringify(order))),
    processing_orders: processingSource.map(order => JSON.parse(JSON.stringify(order))),
  };

  let serialized = JSON.stringify(payload);
  if (serialized.length > ANALYSIS_MAX_DATASET_CHARS){
    payload.meta.truncated = true;
    let trimmedOrders = 0;
    while (serialized.length > ANALYSIS_MAX_DATASET_CHARS && payload.orders.length > 0){
      payload.orders.pop();
      trimmedOrders += 1;
      serialized = JSON.stringify(payload);
    }
    if (trimmedOrders > 0){
      payload.meta.notes.push(`orders list trimmed to newest ${payload.orders.length} to fit token budget`);
    }
    let trimmedProcessing = 0;
    while (serialized.length > ANALYSIS_MAX_DATASET_CHARS && payload.processing_orders.length > 0){
      payload.processing_orders.pop();
      trimmedProcessing += 1;
      serialized = JSON.stringify(payload);
    }
    if (trimmedProcessing > 0){
      payload.meta.notes.push("processing orders trimmed to fit token budget");
    }
    if (serialized.length > ANALYSIS_MAX_DATASET_CHARS){
      payload.orders = [];
      payload.processing_orders = [];
      serialized = JSON.stringify(payload);
    }
  }

  payload.meta.size = serialized.length;
  return { dataset: payload, serialized, truncated: !!payload.meta.truncated };
}

function getAnalysisSessionId(){
  if (analysisState.sessionId){
    return analysisState.sessionId;
  }
  let sessionId = "local";
  try{
    const storage = window.localStorage;
    if (storage){
      const existing = storage.getItem("analysisSessionId");
      if (existing && existing.trim().length){
        sessionId = existing.trim();
      }else{
        const generated = (window.crypto && typeof window.crypto.randomUUID === "function")
          ? window.crypto.randomUUID()
          : `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        storage.setItem("analysisSessionId", generated);
        sessionId = generated;
      }
    }
  }catch{
    sessionId = `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }
  analysisState.sessionId = sessionId || "local";
  return analysisState.sessionId;
}

function computeAnalysisMetrics(orders){
  const count = orders.length;
  const unitsSum = orders.reduce((sum, order)=> sum + (Number(order.parsed_units) || 0), 0);
  const areaSum = orders.reduce((sum, order)=> sum + (Number(order.parsed_area) || 0), 0);
  const avgArea = count ? areaSum / count : 0;
  const avgUnits = count ? unitsSum / count : 0;
  return {
    ordersCount: count,
    unitsSum,
    areaSum,
    avgArea,
    avgUnits,
  };
}

function formatNumber(value, { decimals = 0 } = {}){
  const number = Number(value) || 0;
  return number.toLocaleString(undefined, {
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals,
  });
}

function formatAreaMetric(value, decimals = 3){
  return `${formatNumber(value, { decimals })}\u202Fm²`;
}

function renderAnalysisKpis(metrics){
  const safeMetrics = metrics || { ordersCount: 0, unitsSum: 0, areaSum: 0, avgArea: 0, avgUnits: 0 };
  if (analysisKpiOrdersEl) analysisKpiOrdersEl.textContent = formatNumber(safeMetrics.ordersCount);
  if (analysisKpiUnitsEl) analysisKpiUnitsEl.textContent = formatNumber(safeMetrics.unitsSum);
  if (analysisKpiAreaEl) analysisKpiAreaEl.textContent = formatAreaMetric(safeMetrics.areaSum);
  if (analysisKpiAvgAreaEl) analysisKpiAvgAreaEl.textContent = formatAreaMetric(safeMetrics.avgArea);
  if (analysisKpiAvgUnitsEl) analysisKpiAvgUnitsEl.textContent = formatNumber(safeMetrics.avgUnits, { decimals: 1 });
}

function computeTopClients(orders){
  const map = new Map();
  orders.forEach(order => {
    if (!order) return;
    const client = (order.client && String(order.client).trim()) || "—";
    if (!map.has(client)){
      map.set(client, { client, units: 0, area: 0, orderIds: new Set() });
    }
    const entry = map.get(client);
    entry.units += Number(order.parsed_units) || 0;
    entry.area += Number(order.parsed_area) || 0;
    if (order.id != null){
      const key = String(order.id).trim();
      if (key) entry.orderIds.add(key);
    }else if (order.order_numbers && order.order_numbers.length){
      order.order_numbers.forEach(num => {
        const key = num != null ? String(num).trim() : "";
        if (key) entry.orderIds.add(key);
      });
    }else if (order.order_number){
      const key = String(order.order_number).trim();
      if (key) entry.orderIds.add(key);
    }
  });
  return Array.from(map.values()).map(entry => ({
    client: entry.client,
    units: entry.units,
    area: entry.area,
    orders: entry.orderIds.size || (entry.units > 0 ? 1 : 0),
  })).sort((a, b)=>{
    if (b.area !== a.area) return b.area - a.area;
    if (b.units !== a.units) return b.units - a.units;
    return a.client.localeCompare(b.client);
  }).slice(0, 10);
}

function computeTopGlassTypes(orders){
  const map = new Map();
  orders.forEach(order => {
    if (!order || !Array.isArray(order.rows)) return;
    order.rows.forEach(row => {
      if (!row) return;
      const type = (row.type && String(row.type).trim()) || "—";
      if (!map.has(type)){
        map.set(type, { type, lines: 0, units: 0 });
      }
      const entry = map.get(type);
      entry.lines += 1;
      entry.units += Number(row.qty) || 0;
    });
  });
  return Array.from(map.values()).sort((a, b)=>{
    if (b.units !== a.units) return b.units - a.units;
    if (b.lines !== a.lines) return b.lines - a.lines;
    return a.type.localeCompare(b.type);
  }).slice(0, 10);
}

function renderNoDataRow(bodyEl, colspan){
  if (!bodyEl) return;
  bodyEl.innerHTML = `<tr><td colspan="${colspan}" class="muted">No data.</td></tr>`;
}

function renderTopClients(rows){
  if (!analysisTopClientsBody) return;
  if (!rows.length){
    renderNoDataRow(analysisTopClientsBody, 4);
    return;
  }
  const html = rows.map(entry => `<tr>
    <td>${escapeHtml(entry.client)}</td>
    <td>${formatNumber(entry.orders)}</td>
    <td>${formatNumber(entry.units)}</td>
    <td>${formatAreaMetric(entry.area)}</td>
  </tr>`).join("");
  analysisTopClientsBody.innerHTML = html;
}

function renderTopTypes(rows){
  if (!analysisTopTypesBody) return;
  if (!rows.length){
    renderNoDataRow(analysisTopTypesBody, 3);
    return;
  }
  const html = rows.map(entry => `<tr>
    <td>${escapeHtml(entry.type)}</td>
    <td>${formatNumber(entry.lines)}</td>
    <td>${formatNumber(entry.units)}</td>
  </tr>`).join("");
  analysisTopTypesBody.innerHTML = html;
}

function buildDimensionBuckets(rows, tolerance, orientationAgnostic){
  const buckets = [];
  const tol = Number.isFinite(tolerance) ? tolerance : 1;
  rows.forEach(row => {
    if (!row) return;
    let width = normalizeDimensionNumber(row.width);
    let height = normalizeDimensionNumber(row.height);
    let widthDisplay = row.widthDisplay || null;
    let heightDisplay = row.heightDisplay || null;
    if ((width == null || height == null) && row.dimensionDisplay){
      const parsed = parseDimensionTokens(row.dimensionDisplay);
      if (width == null && parsed.width != null) width = parsed.width;
      if (height == null && parsed.height != null) height = parsed.height;
      if (!widthDisplay && parsed.widthDisplay) widthDisplay = parsed.widthDisplay;
      if (!heightDisplay && parsed.heightDisplay) heightDisplay = parsed.heightDisplay;
    }
    if (!Number.isFinite(width) || !Number.isFinite(height)) return;
    const qty = Number(row.qty) || 0;
    if (qty <= 0) return;
    let canonicalWidth = width;
    let canonicalHeight = height;
    let canonicalWidthDisplay = widthDisplay;
    let canonicalHeightDisplay = heightDisplay;
    if (orientationAgnostic && canonicalWidth > canonicalHeight){
      [canonicalWidth, canonicalHeight] = [canonicalHeight, canonicalWidth];
      [canonicalWidthDisplay, canonicalHeightDisplay] = [canonicalHeightDisplay, canonicalWidthDisplay];
    }
    let bucket = null;
    for (const candidate of buckets){
      if (Math.abs(candidate.widthRef - canonicalWidth) <= tol && Math.abs(candidate.heightRef - canonicalHeight) <= tol){
        bucket = candidate;
        break;
      }
    }
    if (!bucket){
      bucket = {
        widthValues: [],
        heightValues: [],
        widthDisplays: [],
        heightDisplays: [],
        widthDecimals: 0,
        heightDecimals: 0,
        widthRef: canonicalWidth,
        heightRef: canonicalHeight,
        qty: 0,
        orderIds: new Set(),
        clients: new Set(),
      };
      buckets.push(bucket);
    }
    bucket.widthValues.push(canonicalWidth);
    bucket.heightValues.push(canonicalHeight);
    if (canonicalWidthDisplay) bucket.widthDisplays.push(canonicalWidthDisplay);
    if (canonicalHeightDisplay) bucket.heightDisplays.push(canonicalHeightDisplay);
    bucket.widthDecimals = Math.max(bucket.widthDecimals, decimalPlacesFromDisplay(canonicalWidthDisplay));
    bucket.heightDecimals = Math.max(bucket.heightDecimals, decimalPlacesFromDisplay(canonicalHeightDisplay));
    bucket.qty += qty;
    const orderIdValue = row.orderId != null ? String(row.orderId).trim() : "";
    if (orderIdValue && orderIdValue !== "—") bucket.orderIds.add(orderIdValue);
    const clientValue = row.client != null ? String(row.client).trim() : "";
    if (clientValue && clientValue !== "—") bucket.clients.add(clientValue);
  });
  return buckets.map(bucket => {
    const widthNumeric = calculateRepresentativeNumber(bucket.widthValues, bucket.widthDecimals) ?? bucket.widthRef;
    const heightNumeric = calculateRepresentativeNumber(bucket.heightValues, bucket.heightDecimals) ?? bucket.heightRef;
    const widthDisplay = selectRepresentativeDisplay(bucket.widthDisplays, widthNumeric, bucket.widthDecimals);
    const heightDisplay = selectRepresentativeDisplay(bucket.heightDisplays, heightNumeric, bucket.heightDecimals);
    return {
      dimension: `${widthDisplay} × ${heightDisplay}`,
      qty: bucket.qty,
      orders: bucket.orderIds.size,
      clients: bucket.clients.size,
      sortQty: bucket.qty,
    };
  }).sort((a, b)=>{
    if (b.sortQty !== a.sortQty) return b.sortQty - a.sortQty;
    return a.dimension.localeCompare(b.dimension);
  }).slice(0, 20);
}

function renderTopDimensions(rows){
  if (!analysisDimensionsBody) return;
  if (!rows.length){
    renderNoDataRow(analysisDimensionsBody, 4);
    return;
  }
  const html = rows.map(entry => `<tr>
    <td>${escapeHtml(entry.dimension)}</td>
    <td>${formatNumber(entry.qty)}</td>
    <td>${formatNumber(entry.orders)}</td>
    <td>${formatNumber(entry.clients)}</td>
  </tr>`).join("");
  analysisDimensionsBody.innerHTML = html;
}

function readAnalysisSettings(){
  let tolerance = analysisToleranceInput ? Number(analysisToleranceInput.value) : analysisState.tolerance;
  tolerance = clampNumber(tolerance, 0, 5, analysisState.tolerance || 1);
  if (analysisToleranceInput){
    analysisToleranceInput.value = String(tolerance);
  }
  const orientationAgnostic = analysisOrientationToggle ? !!analysisOrientationToggle.checked : true;
  analysisState.tolerance = tolerance;
  analysisState.orientationAgnostic = orientationAgnostic;
  return { tolerance, orientationAgnostic };
}

async function refreshAnalysis(){
  const settings = readAnalysisSettings();
  if (analysisState.loading){
    return analysisState.promise;
  }
  analysisState.loading = true;
  setAnalysisStatus("Loading analysis…");
  const task = (async ()=>{
    try{
      await ensureHistoryLoaded();
      const dataset = await buildAllTimeAnalysisDataset(settings);
      analysisState.dataset = dataset;
      const orders = mergeOrdersForAnalysis(dataset);
      analysisState.metrics = computeAnalysisMetrics(orders);
      analysisState.topClients = computeTopClients(orders);
      analysisState.topTypes = computeTopGlassTypes(orders);
      const rows = collectAnalysisRows(orders);
      analysisState.topDimensions = buildDimensionBuckets(rows, analysisState.tolerance, analysisState.orientationAgnostic);
      renderAnalysisKpis(analysisState.metrics);
      renderTopClients(analysisState.topClients);
      renderTopTypes(analysisState.topTypes);
      renderTopDimensions(analysisState.topDimensions);
      const truncatedNotice = dataset?.meta?.truncated ? " (dataset truncated for AI)" : "";
      const message = orders.length ? `Updated ${new Date().toLocaleTimeString()}${truncatedNotice}` : "No analysis data available.";
      setAnalysisStatus(message);
      analysisState.loading = false;
      return dataset;
    }catch(error){
      console.error("Analysis refresh failed:", error);
      setAnalysisStatus("Analysis unavailable — check connection.");
      analysisState.dataset = null;
      analysisState.metrics = null;
      analysisState.topClients = [];
      analysisState.topTypes = [];
      analysisState.topDimensions = [];
      renderAnalysisKpis(null);
      renderTopClients([]);
      renderTopTypes([]);
      renderTopDimensions([]);
      analysisState.loading = false;
      return null;
    }
  })();
  analysisState.promise = task;
  return task;
}

function recalculateDimensionBuckets(){
  readAnalysisSettings();
  if (!analysisState.dataset){
    refreshAnalysis();
    return;
  }
  const orders = mergeOrdersForAnalysis(analysisState.dataset);
  const rows = collectAnalysisRows(orders);
  analysisState.topDimensions = buildDimensionBuckets(rows, analysisState.tolerance, analysisState.orientationAgnostic);
  renderTopDimensions(analysisState.topDimensions);
  if (analysisState.dataset){
    analysisState.dataset.aggregates = computeAggregatesForAllTime(
      analysisState.dataset.orders || [],
      analysisState.dataset.processing_orders || [],
      {
        tolerance: analysisState.tolerance,
        orientationAgnostic: analysisState.orientationAgnostic,
      }
    );
  }
  setAnalysisStatus(orders.length ? "Dimensions recalculated." : "No analysis data available.");
}

function ensureAnalysisReady(){
  if (!analysisState.initialized){
    initAnalysis();
  }
}

function initAnalysis(){
  if (analysisState.initialized) return;
  analysisState.initialized = true;
  readAnalysisSettings();
  renderAnalysisKpis(null);
  renderTopClients([]);
  renderTopTypes([]);
  renderTopDimensions([]);
  refreshAnalysis();
  if (analysisToleranceInput){
    analysisToleranceInput.addEventListener("change", ()=>{
      readAnalysisSettings();
      recalculateDimensionBuckets();
    });
    analysisToleranceInput.addEventListener("input", ()=> readAnalysisSettings());
  }
  if (analysisOrientationToggle){
    analysisOrientationToggle.addEventListener("change", ()=>{
      readAnalysisSettings();
      recalculateDimensionBuckets();
    });
  }
  if (analysisRecalcBtn){
    analysisRecalcBtn.addEventListener("click", ()=> recalculateDimensionBuckets());
  }
  if (analysisAskBtn){
    analysisAskBtn.addEventListener("click", ()=> submitAnalysisQuestion());
  }
  if (analysisQuestionInput){
    analysisQuestionInput.addEventListener("keydown", event => {
      if (event.key === "Enter"){
        if (event.metaKey || event.ctrlKey){
          event.preventDefault();
          submitAnalysisQuestion();
        }
      }
    });
  }
  if (analysisDebugToggle){
    analysisDebugToggle.addEventListener("click", ()=>{
      const dataset = analysisState.dataset;
      if (!dataset){
        console.log("[analysis debug] No dataset loaded.");
        return;
      }
      const ordersCount = Array.isArray(dataset.orders) ? dataset.orders.length : 0;
      const orderRows = Array.isArray(dataset.orders)
        ? dataset.orders.reduce((sum, order)=> sum + (Array.isArray(order.rows) ? order.rows.length : 0), 0)
        : 0;
      const processingCount = Array.isArray(dataset.processing_orders) ? dataset.processing_orders.length : 0;
      const processingRows = Array.isArray(dataset.processing_orders)
        ? dataset.processing_orders.reduce((sum, order)=> sum + (Array.isArray(order.rows) ? order.rows.length : 0), 0)
        : 0;
      console.log(`[analysis debug] orders=${ordersCount} rows=${orderRows}, processing=${processingCount} rows=${processingRows}, truncated=${dataset.meta?.truncated ? "yes" : "no"}`);
    });
  }
}

function setAnalysisAnswerPlaceholder(message, muted = true){
  if (!analysisAnswerEl) return;
  analysisAnswerEl.textContent = message;
  if (muted){
    analysisAnswerEl.classList.add("muted");
  }else{
    analysisAnswerEl.classList.remove("muted");
  }
}

function formatMarkdownInline(text){
  let html = escapeHtml(text);
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
  return html;
}

function simpleMarkdownToHtml(text){
  const lines = String(text || "").split(/\r?\n/);
  const parts = [];
  let inList = false;
  lines.forEach(line => {
    if (/^\s*-\s+/.test(line)){
      if (!inList){
        parts.push("<ul>");
        inList = true;
      }
      const content = line.replace(/^\s*-\s+/, "");
      parts.push(`<li>${formatMarkdownInline(content)}</li>`);
    }else{
      if (inList){
        parts.push("</ul>");
        inList = false;
      }
      if (!line.trim()){
        parts.push("<br>");
      }else{
        parts.push(`<p>${formatMarkdownInline(line)}</p>`);
      }
    }
  });
  if (inList){
    parts.push("</ul>");
  }
  return parts.join("");
}

function renderAnalysisAnswer(markdown){
  if (!analysisAnswerEl) return;
  if (!markdown){
    setAnalysisAnswerPlaceholder("AI analysis is unavailable. The dashboard above still works offline.", true);
    return;
  }
  analysisAnswerEl.innerHTML = simpleMarkdownToHtml(markdown);
  analysisAnswerEl.classList.remove("muted");
}

async function submitAnalysisQuestion(){
  if (!analysisQuestionInput) return;
  const question = analysisQuestionInput.value.trim();
  if (!question){
    setAnalysisAnswerPlaceholder("Ask a question to see AI insights.", true);
    analysisQuestionInput.focus();
    return;
  }
  ensureAnalysisReady();
  if (analysisState.loading){
    await analysisState.promise;
  }
  if (!analysisState.dataset){
    await refreshAnalysis();
  }
  const dataset = analysisState.dataset;
  if (!dataset){
    setAnalysisAnswerPlaceholder("AI analysis is unavailable. The dashboard above still works offline.", true);
    return;
  }
  const { dataset: payloadDataset, serialized, truncated } = prepareDatasetForTransmission(dataset, {
    tolerance: analysisState.tolerance,
    orientationAgnostic: analysisState.orientationAgnostic,
  });
  if (analysisState.dataset){
    const payloadMeta = payloadDataset.meta || {};
    analysisState.dataset.meta = {
      ...(analysisState.dataset.meta || {}),
      truncated: !!payloadMeta.truncated,
      size: payloadMeta.size ?? serialized.length,
      notes: Array.isArray(payloadMeta.notes) ? payloadMeta.notes.slice() : (analysisState.dataset.meta?.notes || []),
    };
  }
  const sessionId = getAnalysisSessionId();
  const headers = { "Content-Type": "application/json" };
  if (sessionId){
    headers["x-session-id"] = sessionId;
  }
  const payload = {
    question,
    dataset: payloadDataset,
    settings: {
      tolerance_mm: analysisState.tolerance,
      orient_agnostic: analysisState.orientationAgnostic,
      decimal_separator: appState.processing.options.decimalSeparator === "dot" ? "dot" : "comma",
    },
  };
  analysisState.ai.loading = true;
  analysisState.ai.lastQuestion = question;
  if (analysisAskBtn) analysisAskBtn.disabled = true;
  setAnalysisAnswerPlaceholder("Thinking…", true);
  try{
    const res = await fetch(API_BASE + "/analysis/ask", {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
    });
    if (!res.ok){
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    if (data && typeof data.answerMarkdown === "string"){
      renderAnalysisAnswer(data.answerMarkdown);
      analysisQuestionInput.value = "";
      analysisQuestionInput.focus();
    }else{
      setAnalysisAnswerPlaceholder("AI analysis is unavailable. The dashboard above still works offline.", true);
    }
  }catch(error){
    console.warn("AI analysis request failed:", error);
    setAnalysisAnswerPlaceholder("AI analysis is unavailable. The dashboard above still works offline.", true);
  }finally{
    analysisState.ai.loading = false;
    if (analysisAskBtn) analysisAskBtn.disabled = false;
    if (analysisQuestionInput) analysisQuestionInput.focus();
  }
}

function setGlobalAppearanceVariables(settings){
  if (!document.documentElement) return;
  const rootStyle = document.documentElement.style;
  rootStyle.setProperty("--ms-header-size", `${settings.headerFontSize}px`);
  rootStyle.setProperty("--ms-subheader-size", `${settings.orderInfoFontSize}px`);
  rootStyle.setProperty("--ms-body-size", `${settings.bodyFontSize}px`);
  rootStyle.setProperty("--ms-body-line-height", "1.4");
  rootStyle.setProperty("--ms-accent-color", "#2F6BFF");
  let baseFont = "var(--ms-sans-system)";
  let headerFont = "var(--ms-sans-system)";
  let rowsFont = "var(--ms-sans-system)";
  if (settings.fontFamily === "inter"){
    baseFont = headerFont = rowsFont = "var(--ms-inter-stack)";
  }else if (settings.fontFamily === "roboto"){
    baseFont = headerFont = rowsFont = "var(--ms-roboto-stack)";
  }else if (settings.fontFamily === "mono-rows"){
    rowsFont = "var(--ms-mono-stack)";
  }
  rootStyle.setProperty("--ms-family-base", baseFont);
  rootStyle.setProperty("--ms-family-header", headerFont);
  rootStyle.setProperty("--ms-family-rows", rowsFont);
  const densityAdjustments = {
    compact: "-2px",
    normal: "0px",
    roomy: "2px",
  };
  rootStyle.setProperty("--ms-row-spacing-adjust", densityAdjustments[settings.rowDensity] || "0px");
}

function applyAppearanceToNode(node, settings){
  if (!node || !(node instanceof Element)) return;
  const fontClasses = ["font-system","font-inter","font-roboto","font-mono-rows"];
  const densityClasses = ["density-compact","density-normal","density-roomy"];
  const accentClasses = ["accent-none","accent-thinrule","accent-leftbar"];
  node.classList.remove(...fontClasses, ...densityClasses, ...accentClasses);
  const fontMap = {
    "system-sans": ["font-system"],
    inter: ["font-inter"],
    roboto: ["font-roboto"],
    "mono-rows": ["font-system","font-mono-rows"],
  };
  const densityMap = {
    compact: "density-compact",
    normal: "density-normal",
    roomy: "density-roomy",
  };
  const accentMap = {
    none: "accent-none",
    thinrule: "accent-thinrule",
    leftbar: "accent-leftbar",
  };
  (fontMap[settings.fontFamily] || fontMap["system-sans"]).forEach(cls => node.classList.add(cls));
  node.classList.add(densityMap[settings.rowDensity] || densityMap.normal);
  node.classList.add(accentMap[settings.accentStyle] || accentMap.none);
  node.style.setProperty("--ms-header-size", `${settings.headerFontSize}px`);
  node.style.setProperty("--ms-subheader-size", `${settings.orderInfoFontSize}px`);
  node.style.setProperty("--ms-body-size", `${settings.bodyFontSize}px`);
  node.style.setProperty("--ms-body-line-height", "1.4");
  node.style.setProperty("--ms-accent-color", "#2F6BFF");
}

function ensureMotherSheetObserver(){
  if (motherSheetObserver || typeof MutationObserver !== "function" || !document.body) return;
  motherSheetObserver = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      mutation.addedNodes.forEach(node => {
        if (!(node instanceof Element)) return;
        if (node.matches(MOTHER_SHEET_SELECTOR)){
          applyAppearanceToNode(node, appearanceSettings || DEFAULT_APPEARANCE_SETTINGS);
        }else{
          node.querySelectorAll?.(MOTHER_SHEET_SELECTOR).forEach(child => {
            applyAppearanceToNode(child, appearanceSettings || DEFAULT_APPEARANCE_SETTINGS);
          });
        }
      });
    });
  });
  motherSheetObserver.observe(document.body, { childList: true, subtree: true });
}

function setStatusMessage(msg){
  statusEl.innerHTML = msg || "";
}

function escapeHtml(value){
  if (value === null || value === undefined) return "";
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function normalizeHeaderForDisplay(raw, enableLPtoG = true){
  const base = (raw || "").trim().replace(/\s+/g, " ") || "(Header not set)";
  if (!enableLPtoG) return base;
  return base.replace(/\bLP\b/gi, "G");
}

function parseDimensionTokens(dimension){
  const dim = (dimension || "").trim();
  if (!dim) return { width: null, height: null, widthDisplay: "?", heightDisplay: "?", invalid: true };
  const compact = dim.replace(/\s+/g, "");
  const match = compact.match(/^(\d{1,5}(?:[.,]\d{1,3})?)(?:[xX×])(\d{1,5}(?:[.,]\d{1,3})?)$/);
  if (match){
    const parseToken = (value)=>{
      const normalized = value.replace(",", ".");
      const parsed = Number(normalized);
      return Number.isFinite(parsed) ? parsed : null;
    };
    const widthNum = parseToken(match[1]);
    const heightNum = parseToken(match[2]);
    return {
      width: widthNum,
      height: heightNum,
      widthDisplay: match[1],
      heightDisplay: match[2],
      invalid: !Number.isFinite(widthNum) || !Number.isFinite(heightNum),
    };
  }
  const tokens = dim.split(/[xX×]/);
  const widthDisplay = (tokens[0] || "?").trim() || "?";
  const heightDisplay = (tokens[1] || "?").trim() || "?";
  return {
    width: null,
    height: null,
    widthDisplay,
    heightDisplay,
    invalid: true,
  };
}

function formatProcessingNumber(value, fallback, separator){
  if (value == null || Number.isNaN(value)){
    return (fallback !== undefined && fallback !== null && String(fallback).length) ? String(fallback) : "?";
  }
  const str = String(value);
  if (separator === "comma"){
    return str.replace(".", ",");
  }
  return str;
}

function formatM2(value, separator){
  const numeric = Number.isFinite(value) ? value : 0;
  const fixed = numeric.toFixed(3);
  return separator === "comma" ? fixed.replace(".", ",") : fixed;
}

function computeGroupArea(rows){
  const safeRows = Array.isArray(rows) ? rows : [];
  const parseNumeric = (value)=>{
    if (typeof value === "number" && Number.isFinite(value)) return value;
    if (value == null) return NaN;
    const match = String(value).replace(",", ".").match(/-?\d+(?:\.\d+)?/);
    return match ? Number(match[0]) : NaN;
  };
  const pickNumeric = (...values)=>{
    for (const value of values){
      const parsed = parseNumeric(value);
      if (Number.isFinite(parsed)) return parsed;
    }
    return NaN;
  };

  let total = 0;
  safeRows.forEach(row => {
    if (!row) return;
    const qtyRaw = row.qty ?? row.quantity ?? row.count ?? 1;
    let quantity = parseNumeric(qtyRaw);
    if (!Number.isFinite(quantity)){
      quantity = 1;
    }

    let area = pickNumeric(row.area, row.danko?.area, row.__original?.area);
    if (!Number.isFinite(area)){
      let width = pickNumeric(row.width, row.widthValue, row.__original?.width);
      let height = pickNumeric(row.height, row.heightValue, row.__original?.height);
      if (!Number.isFinite(width) || !Number.isFinite(height)){
        const dimensionSources = [
          row.dimension,
          row.dim,
          row.dimension_display,
          row.dimensionDisplay,
          row.__original?.dimension,
          row.widthDisplay && row.heightDisplay ? `${row.widthDisplay}x${row.heightDisplay}` : null,
        ];
        const dimension = dimensionSources.find(value => value && String(value).trim().length);
        if (dimension){
          const match = String(dimension).match(/(\d+(?:[.,]\d+)?)[^\d]+(\d+(?:[.,]\d+)?)/);
          if (match){
            width = parseNumeric(match[1]);
            height = parseNumeric(match[2]);
          }
        }
      }
      if (Number.isFinite(width) && Number.isFinite(height)){
        area = (width * height) / 1_000_000;
      }else{
        area = 0;
      }
    }

    const multiplier = Number.isFinite(quantity) ? quantity : 1;
    if (Number.isFinite(area)){
      total += area * multiplier;
    }
  });
  return Math.round(total * 1000) / 1000;
}

const DIMENSION_TOLERANCE_MM = 1;
const UNKNOWN_CLIENT_LABEL = "(Unknown Client)";

function normalizeDimensionNumber(value){
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "string"){
    const normalized = Number(value.replace(",", "."));
    if (Number.isFinite(normalized)) return normalized;
  }
  return null;
}

function decimalPlacesFromDisplay(display){
  if (!display) return 0;
  const normalized = String(display).trim().replace(",", ".");
  if (!normalized.length) return 0;
  const parts = normalized.split(".");
  if (parts.length !== 2) return 0;
  if (!/^\d+$/.test(parts[0]) || !/^\d+$/.test(parts[1])) return 0;
  return parts[1].length;
}

function calculateRepresentativeNumber(values, decimals){
  if (!values.length) return null;
  const precision = Math.min(Number.isFinite(decimals) ? decimals : 0, 3);
  const factor = Math.pow(10, precision);
  if (!factor || !Number.isFinite(factor)) return values[values.length - 1];
  const sum = values.reduce((acc, val)=> acc + val, 0);
  return Math.round((sum / values.length) * factor) / factor;
}

function selectRepresentativeDisplay(displays, numericValue, decimals){
  const cleaned = (displays || [])
    .map(value => String(value || "").trim())
    .filter(Boolean);
  if (cleaned.length){
    let winner = cleaned[0];
    let best = 0;
    const counts = new Map();
    cleaned.forEach(value=>{
      const count = (counts.get(value) || 0) + 1;
      counts.set(value, count);
      if (count > best){
        best = count;
        winner = value;
      }
    });
    return winner;
  }
  if (numericValue != null){
    const precision = Math.min(Number.isFinite(decimals) ? decimals : 0, 3);
    if (precision > 0){
      return numericValue.toFixed(precision);
    }
    return String(Math.round(numericValue));
  }
  return "?";
}

function collapseGroupDimensions(items, tolerance = DIMENSION_TOLERANCE_MM){
  const buckets = [];
  items.forEach(item => {
    const widthNum = normalizeDimensionNumber(item.width);
    const heightNum = normalizeDimensionNumber(item.height);
    const widthKey = (item.widthDisplay || "").trim().toLowerCase();
    const heightKey = (item.heightDisplay || "").trim().toLowerCase();
    const widthDecimals = decimalPlacesFromDisplay(item.widthDisplay);
    const heightDecimals = decimalPlacesFromDisplay(item.heightDisplay);

    let bucket = null;
    for (const candidate of buckets){
      if (
        candidate.hasNumeric &&
        widthNum != null &&
        heightNum != null &&
        Math.abs(candidate.widthReference - widthNum) <= tolerance &&
        Math.abs(candidate.heightReference - heightNum) <= tolerance
      ){
        bucket = candidate;
        break;
      }
      if (
        !candidate.hasNumeric &&
        widthNum == null &&
        heightNum == null &&
        candidate.widthKey &&
        candidate.widthKey === widthKey &&
        candidate.heightKey &&
        candidate.heightKey === heightKey
      ){
        bucket = candidate;
        break;
      }
    }

    if (!bucket){
      bucket = {
        widthValues: [],
        heightValues: [],
        widthDisplays: [],
        heightDisplays: [],
        widthDecimals: 0,
        heightDecimals: 0,
        widthReference: widthNum != null ? widthNum : 0,
        heightReference: heightNum != null ? heightNum : 0,
        hasNumeric: widthNum != null && heightNum != null,
        widthKey: widthKey || null,
        heightKey: heightKey || null,
        qty: 0,
        invalid: false,
        orderIds: new Set(),
        clients: new Set(),
      };
      buckets.push(bucket);
    }

    if (widthNum != null){
      bucket.widthValues.push(widthNum);
      bucket.widthDecimals = Math.max(bucket.widthDecimals, widthDecimals);
      bucket.widthReference = calculateRepresentativeNumber(bucket.widthValues, bucket.widthDecimals);
    }
    if (heightNum != null){
      bucket.heightValues.push(heightNum);
      bucket.heightDecimals = Math.max(bucket.heightDecimals, heightDecimals);
      bucket.heightReference = calculateRepresentativeNumber(bucket.heightValues, bucket.heightDecimals);
    }

    if (widthNum != null && heightNum != null){
      bucket.hasNumeric = true;
    }

    if (item.widthDisplay) bucket.widthDisplays.push(item.widthDisplay);
    if (item.heightDisplay) bucket.heightDisplays.push(item.heightDisplay);
    bucket.qty += Number(item.qty || 0);
    bucket.invalid = bucket.invalid || !!item.invalidDimension;
    if (item.orderId) bucket.orderIds.add(item.orderId);
    if (item.client) bucket.clients.add(item.client);
  });

  return buckets.map(bucket => {
    const widthNumeric = bucket.widthValues.length ? calculateRepresentativeNumber(bucket.widthValues, bucket.widthDecimals) : null;
    const heightNumeric = bucket.heightValues.length ? calculateRepresentativeNumber(bucket.heightValues, bucket.heightDecimals) : null;
    const widthDisplay = selectRepresentativeDisplay(bucket.widthDisplays, widthNumeric, bucket.widthDecimals);
    const heightDisplay = selectRepresentativeDisplay(bucket.heightDisplays, heightNumeric, bucket.heightDecimals);
    const orderIdsList = Array.from(bucket.orderIds).filter(Boolean);
    const clientsList = Array.from(bucket.clients).filter(Boolean);
    const orderId = orderIdsList.join(", ");
    const client = clientsList.length === 1 ? clientsList[0] : (clientsList.length ? "(Mixed)" : "—");
    return {
      width: widthNumeric,
      height: heightNumeric,
      widthDisplay,
      heightDisplay,
      qty: bucket.qty,
      invalid: bucket.invalid,
      orderId,
      client,
      sortWidth: Number.isFinite(widthNumeric) ? widthNumeric : Number.POSITIVE_INFINITY,
      sortHeight: Number.isFinite(heightNumeric) ? heightNumeric : Number.POSITIVE_INFINITY,
      sortWidthKey: String(widthDisplay || "").toLowerCase(),
      sortHeightKey: String(heightDisplay || "").toLowerCase(),
    };
  });
}

function generateMotherSheet(rows, options){
  const {
    restartPerGroup,
    decimalSeparator,
    normalizeLPtoG,
    headerOverrides = {},
    groupDimensions = false,
    mergeAcrossOrders = false,
  } = options;
  const grouped = new Map();
  const orderSet = new Set();
  const clientSet = new Set();
  (rows || []).forEach(row => {
    if (!row) return;
    const key = (row.composition_raw || row.composition || "").trim() || "(Header not set)";
    if (!grouped.has(key)) grouped.set(key, []);
    const normalizedRow = {
      ...row,
      widthDisplay: row.widthDisplay ?? (Number.isFinite(row.width) ? String(row.width) : row.widthDisplay),
      heightDisplay: row.heightDisplay ?? (Number.isFinite(row.height) ? String(row.height) : row.heightDisplay),
    };
    grouped.get(key).push(normalizedRow);
    if (row.orderId) orderSet.add(row.orderId);
    const clientValue = row.client && String(row.client).trim();
    if (clientValue) clientSet.add(clientValue);
  });

  const sortCollapsedEntries = (entries)=>{
    return entries.sort((a, b)=>{
      const aWidthFinite = Number.isFinite(a.sortWidth);
      const bWidthFinite = Number.isFinite(b.sortWidth);
      if (aWidthFinite && bWidthFinite && a.sortWidth !== b.sortWidth){
        return a.sortWidth - b.sortWidth;
      }
      if (aWidthFinite && !bWidthFinite) return -1;
      if (!aWidthFinite && bWidthFinite) return 1;

      const aHeightFinite = Number.isFinite(a.sortHeight);
      const bHeightFinite = Number.isFinite(b.sortHeight);
      if (aHeightFinite && bHeightFinite && a.sortHeight !== b.sortHeight){
        return a.sortHeight - b.sortHeight;
      }
      if (aHeightFinite && !bHeightFinite) return -1;
      if (!aHeightFinite && bHeightFinite) return 1;

      if (a.sortWidthKey !== b.sortWidthKey){
        return a.sortWidthKey.localeCompare(b.sortWidthKey);
      }
      if (a.sortHeightKey !== b.sortHeightKey){
        return a.sortHeightKey.localeCompare(b.sortHeightKey);
      }
      return 0;
    });
  };

  const groups = [];
  let runningIndex = 1;
  let totalLines = 0;

  for (const [raw, items] of grouped.entries()){
    const override = headerOverrides[raw];
    const display = override && override.trim().length ? override.trim() : normalizeHeaderForDisplay(raw, normalizeLPtoG);
    let localIndex = restartPerGroup ? 1 : runningIndex;
    const assignIndex = ()=> restartPerGroup ? localIndex++ : runningIndex++;

    const groupLines = [];
    const sections = [];

    if (mergeAcrossOrders){
      let working = [];
      if (groupDimensions){
        working = collapseGroupDimensions(items, DIMENSION_TOLERANCE_MM);
        sortCollapsedEntries(working);
      }else{
        working = items.map(item => ({
          width: item.width,
          height: item.height,
          widthDisplay: item.widthDisplay,
          heightDisplay: item.heightDisplay,
          qty: item.qty ?? 0,
          invalid: !!item.invalidDimension,
          orderId: item.orderId || "",
          client: item.client && String(item.client).trim().length ? item.client : UNKNOWN_CLIENT_LABEL,
          sortWidth: Number.isFinite(item.width) ? item.width : Number.POSITIVE_INFINITY,
          sortHeight: Number.isFinite(item.height) ? item.height : Number.POSITIVE_INFINITY,
          sortWidthKey: String(item.widthDisplay || "").toLowerCase(),
          sortHeightKey: String(item.heightDisplay || "").toLowerCase(),
          danko: item.danko || null,
        }));
      }

      working.forEach(entry => {
        const idx = assignIndex();
        const line = {
          idx,
          width: entry.width,
          height: entry.height,
          widthDisplay: entry.widthDisplay,
          heightDisplay: entry.heightDisplay,
          qty: entry.qty ?? 0,
          orderId: entry.orderId || "",
          client: entry.client || UNKNOWN_CLIENT_LABEL,
          composition_raw: raw,
          composition_display: display,
          invalid: !!entry.invalid,
          danko: entry.danko || null,
        };
        groupLines.push(line);
      });

      if (restartPerGroup) runningIndex = localIndex;
      totalLines += groupLines.length;
      groups.push({ raw, display, lines: groupLines, sections: null });
      continue;
    }

    const orderBuckets = new Map();
    items.forEach(item => {
      const orderKey = (item.orderId || "").trim() || "—";
      if (!orderBuckets.has(orderKey)) orderBuckets.set(orderKey, []);
      orderBuckets.get(orderKey).push(item);
    });

    for (const [orderKey, orderItems] of orderBuckets.entries()){
      const clientName = orderItems.find(row => row.client && String(row.client).trim().length)?.client || "";
      const clientDisplay = clientName && clientName.trim().length ? clientName.trim() : UNKNOWN_CLIENT_LABEL;
      let entryList = [];
      if (groupDimensions){
        entryList = collapseGroupDimensions(orderItems, DIMENSION_TOLERANCE_MM).map(entry => {
          entry.orderId = orderKey;
          entry.client = clientDisplay;
          return entry;
        });
        sortCollapsedEntries(entryList);
      }else{
        entryList = orderItems.map(item => ({
          width: item.width,
          height: item.height,
          widthDisplay: item.widthDisplay,
          heightDisplay: item.heightDisplay,
          qty: item.qty ?? 0,
          invalid: !!item.invalidDimension,
          orderId: item.orderId || orderKey,
          client: item.client && String(item.client).trim().length ? item.client : clientDisplay,
          sortWidth: Number.isFinite(item.width) ? item.width : Number.POSITIVE_INFINITY,
          sortHeight: Number.isFinite(item.height) ? item.height : Number.POSITIVE_INFINITY,
          sortWidthKey: String(item.widthDisplay || "").toLowerCase(),
          sortHeightKey: String(item.heightDisplay || "").toLowerCase(),
          danko: item.danko || null,
        }));
      }

      const section = {
        orderId: orderKey,
        client: clientDisplay,
        lines: [],
      };

      entryList.forEach(entry => {
        const idx = assignIndex();
        const line = {
          idx,
          width: entry.width,
          height: entry.height,
          widthDisplay: entry.widthDisplay,
          heightDisplay: entry.heightDisplay,
          qty: entry.qty ?? 0,
          orderId: entry.orderId || orderKey,
          client: entry.client || clientDisplay,
          composition_raw: raw,
          composition_display: display,
          invalid: !!entry.invalid,
          danko: entry.danko || null,
        };
        section.lines.push(line);
        groupLines.push(line);
      });
      sections.push(section);
    }

    if (restartPerGroup) runningIndex = localIndex;
    totalLines += groupLines.length;
    groups.push({ raw, display, lines: groupLines, sections });
  }

  const orders = Array.from(orderSet).filter(Boolean);
  const clients = Array.from(clientSet);
  const clientLabel = clients.length === 1 ? clients[0] : (clients.length ? "(Mixed)" : UNKNOWN_CLIENT_LABEL);
  const today = new Date();
  const headerLine = `Mother Sheet – Client: ${clientLabel || UNKNOWN_CLIENT_LABEL} | Orders: ${orders.length ? orders.join(", ") : "—"} | Date: ${today.toLocaleDateString()}`;

  const linesOut = [headerLine, ""];
  groups.forEach((group, groupIndex) => {
    const groupLabel = group && group.display ? group.display : "(Header not set)";
    const groupAreaValue = computeGroupArea(group?.lines || []);
    const groupAreaText = formatM2(groupAreaValue, decimalSeparator);
    linesOut.push(`${groupLabel} — Area: ${groupAreaText} m²`);
    if (!mergeAcrossOrders && group.sections && group.sections.length){
      group.sections.forEach((section, sectionIndex) => {
        const orderLabel = section.orderId && section.orderId.trim().length ? section.orderId : "—";
        const clientLabelForSection = section.client && section.client.trim().length ? section.client : UNKNOWN_CLIENT_LABEL;
        linesOut.push(`[Order ${orderLabel} — ${clientLabelForSection}]`);
        section.lines.forEach(line => {
          const widthText = formatProcessingNumber(line.width, line.widthDisplay, decimalSeparator);
          const heightText = formatProcessingNumber(line.height, line.heightDisplay, decimalSeparator);
          const qtyText = Number(line.qty || 0);
          const warning = line.invalid ? "  ⚠" : "";
          const approx = line.danko && line.danko.changed ? " ≈" : "";
          linesOut.push(`${line.idx} ${widthText} × ${heightText}${approx} × ${qtyText}${warning}`);
          if (line.danko && line.danko.changed && line.danko.original){
            linesOut.push(`   (Rounded from ${line.danko.original.replace(/x/g, "×")})`);
          }
        });
        if (sectionIndex < group.sections.length - 1){
          linesOut.push("");
        }
      });
    }else{
      group.lines.forEach(line => {
        const widthText = formatProcessingNumber(line.width, line.widthDisplay, decimalSeparator);
        const heightText = formatProcessingNumber(line.height, line.heightDisplay, decimalSeparator);
        const qtyText = Number(line.qty || 0);
        const warning = line.invalid ? "  ⚠" : "";
        const approx = line.danko && line.danko.changed ? " ≈" : "";
        linesOut.push(`${line.idx} ${widthText} × ${heightText}${approx} × ${qtyText}${warning}`);
        if (line.danko && line.danko.changed && line.danko.original){
          linesOut.push(`   (Rounded from ${line.danko.original.replace(/x/g, "×")})`);
        }
      });
    }
    if (groupIndex < groups.length - 1){
      linesOut.push("");
    }
  });

  const meta = {
    clientLabel,
    orders,
    date: today,
    rows: totalLines,
    decimalSeparator,
  };

  return {
    text: linesOut.join("\n").trim(),
    groups,
    meta,
  };
}

function convertOrderToProcessingEntry(order){
  const id = Number(order.id) || order.id;
  const orderLabel = (Array.isArray(order.order_numbers) && order.order_numbers.length)
    ? order.order_numbers.join(", ")
    : (order.order_number || `#${order.id}`);
  const client = order.client || order.client_hint || "—";
  const rows = (order.rows || []).map((row, idx) => {
    const parsed = parseDimensionTokens(row.dimension || "");
    const positionValue = [
      row.position,
      row.position_label,
      row.positionLabel,
      row.pos,
      row.position_display,
    ].map(value => (value == null ? "" : String(value).trim())).find(value => value.length) || "";
    return {
      key: row.id || `${order.id}-${idx}`,
      composition_raw: (row.type || "").trim() || "(Header not set)",
      width: parsed.width,
      height: parsed.height,
      widthDisplay: parsed.widthDisplay,
      heightDisplay: parsed.heightDisplay,
      qty: Number(row.quantity || 0) || 0,
      orderId: orderLabel,
      client,
      position: positionValue,
      invalidDimension: parsed.invalid,
    };
  });
  return {
    id,
    orderLabel,
    client,
    createdAt: order.created_at || null,
    rows,
  };
}

function rebuildProcessingRows(){
  const combined = [];
  appState.processing.cart.forEach(entry => {
    entry.rows.forEach(row => {
      const clone = { ...row };
      clone.rawDimension = deriveRawDimension(clone);
      combined.push(clone);
    });
  });
  appState.processing.rows = combined.map(row => {
    const clone = { ...row };
    clone.rawDimension = deriveRawDimension(clone);
    const widthNumeric = Number.isFinite(clone.width) ? Number(clone.width) : null;
    const heightNumeric = Number.isFinite(clone.height) ? Number(clone.height) : null;
    const computedArea = (widthNumeric != null && heightNumeric != null)
      ? Number(((widthNumeric * heightNumeric) / 1_000_000).toFixed(3))
      : (Number.isFinite(clone.area) ? Number(clone.area) : null);
    clone.__original = {
      width: widthNumeric,
      height: heightNumeric,
      widthDisplay: clone.widthDisplay != null ? String(clone.widthDisplay) : (widthNumeric != null ? String(widthNumeric) : null),
      heightDisplay: clone.heightDisplay != null ? String(clone.heightDisplay) : (heightNumeric != null ? String(heightNumeric) : null),
      area: computedArea,
      dimension: clone.rawDimension,
    };
    return clone;
  });
  applyProcessingRoundingToRows();
  const validKeys = new Set(appState.processing.rows.map(row => (row.composition_raw || "").trim() || "(Header not set)"));
  Object.keys(appState.processing.headerOverrides).forEach(key => {
    if (!validKeys.has(key)){
      delete appState.processing.headerOverrides[key];
    }
  });
  recalcProcessingPreview();
  if (!appState.processing.rows.length){
    appState.processing.preview = {
      text: "",
      groups: [],
      meta: { clientLabel: "—", orders: [], date: new Date(), rows: 0, decimalSeparator: appState.processing.options.decimalSeparator },
    };
    setProcessingRoundingMessage("");
  }
}

function formatProcessingMeta(meta){
  const dateStr = meta.date ? new Date(meta.date).toLocaleDateString() : new Date().toLocaleDateString();
  const ordersPart = (meta.orders && meta.orders.length) ? meta.orders.join(", ") : "—";
  const clientPart = meta.clientLabel || "—";
  return `Mother Sheet – Client: ${clientPart} | Orders: ${ordersPart} | Date: ${dateStr}`;
}

function buildDankoDisplay(width, height, displayW, displayH, rounded){
  const baseWidth = Number.isFinite(width) ? width : null;
  const baseHeight = Number.isFinite(height) ? height : null;
  if (!rounded || rounded.changed !== true){
    return {
      widthValue: baseWidth,
      heightValue: baseHeight,
      widthDisplay: displayW,
      heightDisplay: displayH,
      text: displayW && displayH ? `${displayW} × ${displayH}` : `${displayW || baseWidth || "?"} × ${displayH || baseHeight || "?"}`,
      tooltip: null,
      changed: false,
      area: baseWidth != null && baseHeight != null ? (baseWidth * baseHeight) / 1_000_000 : null,
    };
  }
  const widthRounded = rounded.w;
  const heightRounded = rounded.h;
  const text = `${widthRounded} × ${heightRounded}`;
  const tooltip = rounded.original ? `Rounded from ${rounded.original.replace(/x/g, "×")}` : null;
  const area = Number.isFinite(widthRounded) && Number.isFinite(heightRounded)
    ? (widthRounded * heightRounded) / 1_000_000
    : (baseWidth != null && baseHeight != null ? (baseWidth * baseHeight) / 1_000_000 : null);
  return {
    widthValue: widthRounded,
    heightValue: heightRounded,
    widthDisplay: String(widthRounded),
    heightDisplay: String(heightRounded),
    text,
    tooltip,
    changed: true,
    area,
  };
}

function deriveRawDimension(row){
  const candidates = [
    row.rawDimension,
    row.dimension,
    row.dimension_display,
    row.dim,
    row.widthDisplay && row.heightDisplay ? `${row.widthDisplay}x${row.heightDisplay}` : null,
    Number.isFinite(row.width) && Number.isFinite(row.height) ? `${Math.round(row.width)}x${Math.round(row.height)}` : null,
  ];
  const found = candidates.find(value => value && String(value).trim().length);
  return found ? String(found).replace(/\s+/g, "") : "";
}

function isProcessingRoundingActive(){
  return !!(appState.processing.options.autoDanko || appState.processing.rounding.manualApplied);
}

function applyProcessingRoundingToRows(){
  const rows = Array.isArray(appState.processing.rows) ? appState.processing.rows : [];
  const active = isProcessingRoundingActive();
  rows.forEach(row => {
    if (!row.__original){
      const dimension = deriveRawDimension(row);
      const areaFromRow = Number.isFinite(row.area) ? Number(row.area) : null;
      const widthNumeric = Number.isFinite(row.width) ? Number(row.width) : null;
      const heightNumeric = Number.isFinite(row.height) ? Number(row.height) : null;
      const computedArea = (widthNumeric != null && heightNumeric != null)
        ? Number(((widthNumeric * heightNumeric) / 1_000_000).toFixed(3))
        : areaFromRow;
      row.__original = {
        width: widthNumeric,
        height: heightNumeric,
        widthDisplay: row.widthDisplay != null ? String(row.widthDisplay) : (widthNumeric != null ? String(widthNumeric) : null),
        heightDisplay: row.heightDisplay != null ? String(row.heightDisplay) : (heightNumeric != null ? String(heightNumeric) : null),
        area: computedArea,
        dimension,
      };
    }
    const original = row.__original;
    const dimensionString = original.dimension || deriveRawDimension(row) || "";
    const danko = window.applyDankoRuleToDim(dimensionString);
    const tooltipBase = dimensionString ? dimensionString.replace(/x/g, "×") : "";
    row.danko = {
      ...danko,
      original: danko.original || dimensionString,
      tooltip: danko.changed && tooltipBase ? `Rounded from ${tooltipBase}` : (tooltipBase ? `Original ${tooltipBase}` : ""),
    };
    if (active && danko && danko.changed){
      row.width = danko.w;
      row.height = danko.h;
      row.widthDisplay = String(danko.w);
      row.heightDisplay = String(danko.h);
      if (Number.isFinite(danko.w) && Number.isFinite(danko.h)){
        row.area = Number(((danko.w * danko.h) / 1_000_000).toFixed(3));
      }else{
        row.area = original.area;
      }
    }else{
      row.width = original.width;
      row.height = original.height;
      row.widthDisplay = original.widthDisplay;
      row.heightDisplay = original.heightDisplay;
      row.area = original.area;
      if (row.danko){
        row.danko.changed = false;
      }
    }
  });
}

function recalcProcessingPreview(){
  const rows = Array.isArray(appState.processing.rows) ? appState.processing.rows : [];
  if (!rows.length){
    appState.processing.preview = {
      text: "",
      groups: [],
      meta: {
        clientLabel: "—",
        orders: [],
        date: new Date(),
        rows: 0,
        decimalSeparator: appState.processing.options.decimalSeparator,
      },
    };
    return;
  }
  const preview = generateMotherSheet(rows, {
    restartPerGroup: appState.processing.options.restartPerGroup,
    decimalSeparator: appState.processing.options.decimalSeparator,
    normalizeLPtoG: appState.processing.options.normalizeLPtoG,
    headerOverrides: appState.processing.headerOverrides,
    groupDimensions: appState.processing.grouped,
    mergeAcrossOrders: appState.processing.options.mergeAcrossOrders,
  });
  appState.processing.preview = preview;
}

function setProcessingRoundingMessage(message){
  appState.processing.rounding.message = message || "";
  if (processingRoundingStatus){
    processingRoundingStatus.textContent = message || "";
  }
}

function updateProcessingRoundingControls(){
  const auto = !!appState.processing.options.autoDanko;
  const active = isProcessingRoundingActive();
  const hasRows = Array.isArray(appState.processing.rows) && appState.processing.rows.length > 0;
  if (processingRoundingBtn){
    if (!hasRows){
      processingRoundingBtn.textContent = "Apply Danko Rounding";
    }else{
      processingRoundingBtn.textContent = active ? "Undo Danko Rounding" : "Apply Danko Rounding";
    }
    processingRoundingBtn.disabled = auto || !hasRows;
  }
  if (processingAutoDankoToggle){
    processingAutoDankoToggle.checked = auto;
  }
  if (processingRoundingStatus){
    const message = appState.processing.rounding.message;
    if (message){
      processingRoundingStatus.textContent = message;
    }else if (auto){
      processingRoundingStatus.textContent = "Auto Danko rounding enabled. ✅";
    }else if (active){
      processingRoundingStatus.textContent = "Rounded values applied using Danko Rule ✅";
    }else{
      processingRoundingStatus.textContent = "";
    }
  }
}

function updateProcessingUI(){
  const listEl = processingOrderList;
  if (processingRestartToggle){
    processingRestartToggle.checked = !!appState.processing.options.restartPerGroup;
  }
  if (processingNormalizeToggle){
    processingNormalizeToggle.checked = !!appState.processing.options.normalizeLPtoG;
  }
  if (processingDecimalSelect){
    processingDecimalSelect.value = appState.processing.options.decimalSeparator === "dot" ? "dot" : "comma";
  }
  if (processingMergeOrdersToggle){
    processingMergeOrdersToggle.checked = !!appState.processing.options.mergeAcrossOrders;
  }
  if (listEl){
    if (!appState.processing.cart.length){
      listEl.classList.add("processing-empty");
      listEl.innerHTML = "No orders added yet.";
    }else{
      listEl.classList.remove("processing-empty");
      listEl.innerHTML = appState.processing.cart.map(entry => {
        const created = entry.createdAt ? formatDate(entry.createdAt) : "—";
        return `<div class="processing-order-item" data-id="${entry.id}">
          <header>
            <span>${escapeHtml(entry.orderLabel)}</span>
            <button class="btn small danger" data-remove-processing="${entry.id}">Remove</button>
          </header>
          <div class="muted small">${escapeHtml(entry.client || "—")} • ${escapeHtml(created)}</div>
        </div>`;
      }).join("");
    }
  }

  if (processingClearBtn){
    processingClearBtn.disabled = !appState.processing.cart.length;
  }

  if (processingGroupBtn){
    const hasRows = appState.processing.rows && appState.processing.rows.length;
    processingGroupBtn.disabled = !hasRows;
    processingGroupBtn.textContent = appState.processing.grouped ? "Ungroup Dimensions" : "Group Dimensions";
  }

  const preview = appState.processing.preview;
  if (processingMetaEl){
    const metaLine = preview.text ? formatProcessingMeta(preview.meta || {}) : "Mother Sheet – Client: — | Orders: — | Date: —";
    const rowsCount = preview.meta && preview.meta.rows ? preview.meta.rows : appState.processing.rows.length;
    processingMetaEl.innerHTML = `<span>${escapeHtml(metaLine)}</span><span class="muted small">Rows: ${rowsCount}</span>`;
  }

  if (processingPreviewEl){
    if (!preview.text){
      processingPreviewEl.textContent = "No orders added yet.";
    }else{
      processingPreviewEl.textContent = preview.text;
    }
  }

  updateProcessingRoundingControls();

  if (processingHeaderSelect){
    const groups = preview.groups || [];
    if (!groups.length){
      processingHeaderSelect.innerHTML = '<option value="" disabled selected>No groups available</option>';
      processingHeaderSelect.disabled = true;
      if (processingHeaderInput){
        processingHeaderInput.value = "";
        processingHeaderInput.disabled = true;
      }
      if (processingHeaderApply) processingHeaderApply.disabled = true;
      if (processingHeaderReset) processingHeaderReset.disabled = true;
      if (processingHeaderHint) processingHeaderHint.hidden = true;
    }else{
      processingHeaderSelect.disabled = false;
      if (processingHeaderInput) processingHeaderInput.disabled = false;
      if (processingHeaderApply) processingHeaderApply.disabled = false;
      if (processingHeaderReset) processingHeaderReset.disabled = false;
      const previousRaw = processingHeaderSelect.value;
      const options = groups.map(group => {
        const override = appState.processing.headerOverrides[group.raw] || "";
        const display = override || group.display || "(Header not set)";
        return `<option value="${escapeHtml(group.raw)}">${escapeHtml(display)}</option>`;
      }).join("");
      processingHeaderSelect.innerHTML = options;
      const selectedRaw = groups.some(group => group.raw === previousRaw) ? previousRaw : groups[0].raw;
      const override = appState.processing.headerOverrides[selectedRaw] || "";
      processingHeaderSelect.value = selectedRaw;
      if (processingHeaderInput){
        const selectedGroup = groups.find(group => group.raw === selectedRaw) || groups[0];
        processingHeaderInput.value = override || selectedGroup.display || "";
      }
      syncProcessingHeaderEditor();
    }
  }

  if (wysiwygToggle && wysiwygPreview){
    if (wysiwygToggle.checked){
      if (processingPreviewEl) processingPreviewEl.hidden = true;
      wysiwygPreview.hidden = false;
      renderMotherSheetHTML(preview);
    }else{
      if (processingPreviewEl) processingPreviewEl.hidden = false;
      wysiwygPreview.hidden = true;
    }
  }
}

if (wysiwygToggle){
  wysiwygToggle.addEventListener("change", ()=>{
    const show = !!wysiwygToggle.checked;
    if (show){
      if (processingPreviewEl) processingPreviewEl.hidden = true;
      if (wysiwygPreview){
        wysiwygPreview.hidden = false;
        renderMotherSheetHTML(appState.processing.preview || { groups: [], meta: {} });
      }
    }else{
      if (processingPreviewEl) processingPreviewEl.hidden = false;
      if (wysiwygPreview) wysiwygPreview.hidden = true;
    }
  });
}

function renderMotherSheetHTML(preview){
  if (!wysiwygPreview) return;
  const data = preview && typeof preview === "object" ? preview : { groups: [], meta: {} };
  wysiwygPreview.innerHTML = "";

  const root = document.createElement("div");
  root.id = "motherSheet";
  root.className = "mother-sheet";

  const metaLine = document.createElement("div");
  metaLine.className = "meta-line ms-title";
  metaLine.textContent = formatProcessingMeta(data.meta || {});
  root.appendChild(metaLine);

  const groups = Array.isArray(data.groups) ? data.groups : [];
  const decimalSeparator = data.meta?.decimalSeparator || appState.processing.options.decimalSeparator || "comma";
  if (!groups.length){
    const empty = document.createElement("p");
    empty.className = "muted";
    empty.textContent = "No orders added yet.";
    root.appendChild(empty);
  }else{
    groups.forEach(group => {
      const section = document.createElement("section");

      const title = document.createElement("h2");
      title.className = "ms-section-title ms-group-title";
      const label = group && group.display ? group.display : "(Header not set)";
      const areaValue = computeGroupArea(group?.lines || []);
      const areaText = formatM2(areaValue, decimalSeparator);
      title.textContent = `${label} — Area: ${areaText} m²`;
      section.appendChild(title);

      const subSections = Array.isArray(group.sections) && group.sections.length ? group.sections : null;
      if (subSections){
        subSections.forEach(sub => {
          const orderInfo = document.createElement("div");
          orderInfo.className = "ms-order-info";
          const orderLabel = sub && sub.orderId ? sub.orderId : "—";
          const clientLabel = sub && sub.client ? sub.client : UNKNOWN_CLIENT_LABEL;
          orderInfo.textContent = `[Order ${orderLabel} — ${clientLabel}]`;
          section.appendChild(orderInfo);
          section.appendChild(buildGroupTable(sub && Array.isArray(sub.lines) ? sub.lines : [], data));
        });
      }else{
        section.appendChild(buildGroupTable(group && Array.isArray(group.lines) ? group.lines : [], data));
      }

      root.appendChild(section);
    });
  }

  wysiwygPreview.appendChild(root);
  applyAppearanceToNode(root, appearanceSettings || DEFAULT_APPEARANCE_SETTINGS);
}

function buildGroupTable(lines, preview){
  const table = document.createElement("table");
  const tbody = document.createElement("tbody");
  const safeLines = Array.isArray(lines) ? lines : [];
  const separator = (preview && preview.meta && preview.meta.decimalSeparator) || appState.processing.options.decimalSeparator;

  if (!safeLines.length){
    const row = document.createElement("tr");
    row.classList.add("ms-row");
    const cell = document.createElement("td");
    cell.colSpan = 3;
    cell.className = "muted";
    cell.textContent = "No line items.";
    row.appendChild(cell);
    tbody.appendChild(row);
  }else{
    safeLines.forEach(line => {
      const tr = document.createElement("tr");
      tr.classList.add("ms-row");

      const idxCell = document.createElement("td");
      idxCell.textContent = line && line.idx != null ? line.idx : "";
      tr.appendChild(idxCell);

      const dimCell = document.createElement("td");
      const widthText = formatProcessingNumber(line?.width, line?.widthDisplay, separator);
      const heightText = formatProcessingNumber(line?.height, line?.heightDisplay, separator);
      if (line?.danko?.changed){
        const tooltip = line.danko.tooltip || `Rounded from ${(line.danko.original || "").replace(/x/g, "×")}`;
        dimCell.innerHTML = `${escapeHtml(widthText)} × ${escapeHtml(heightText)} <span title="${escapeHtml(tooltip)}">≈</span>`;
      }else{
        dimCell.textContent = `${widthText} × ${heightText}`;
      }
      dimCell.dataset.column = "dimension";
      tr.appendChild(dimCell);

      const qtyCell = document.createElement("td");
      qtyCell.textContent = line && line.qty != null ? line.qty : "";
      tr.appendChild(qtyCell);

      tbody.appendChild(tr);
    });
  }

  table.appendChild(tbody);
  return table;
}

function addOrderToProcessing(order){
  const entry = convertOrderToProcessingEntry(order);
  const entryKey = String(entry.id);
  const existingIndex = appState.processing.cart.findIndex(item => String(item.id) === entryKey);
  if (existingIndex >= 0){
    appState.processing.cart.splice(existingIndex, 1, entry);
  }else{
    appState.processing.cart.push(entry);
  }
  rebuildProcessingRows();
  updateProcessingUI();
  updateLabelsUI();
}

function removeOrderFromProcessing(orderId){
  const key = String(orderId);
  appState.processing.cart = appState.processing.cart.filter(entry => String(entry.id) !== key);
  rebuildProcessingRows();
  updateProcessingUI();
  updateLabelsUI();
}

function clearProcessing(){
  appState.processing.cart = [];
  appState.processing.rows = [];
  appState.processing.headerOverrides = {};
  appState.processing.grouped = false;
  appState.processing.preview = { text: "", groups: [], meta: { clientLabel: "—", orders: [], date: new Date(), rows: 0 } };
  updateProcessingUI();
  updateLabelsUI();
}

function setLabelsStatus(msg){
  if (labelsStatusEl){
    labelsStatusEl.textContent = msg || "";
  }
}

function deriveLabelDimension(row){
  const candidates = [
    row.dimension,
    row.dimension_display,
    row.dim,
  ];
  for (const candidate of candidates){
    if (candidate && String(candidate).trim().length){
      return String(candidate).trim().replace(/\s+/g, " ");
    }
  }
  const widthDisplay = row.widthDisplay != null ? String(row.widthDisplay).trim() : "";
  const heightDisplay = row.heightDisplay != null ? String(row.heightDisplay).trim() : "";
  const widthNumeric = Number.isFinite(row.width) ? String(row.width) : "";
  const heightNumeric = Number.isFinite(row.height) ? String(row.height) : "";
  if (widthDisplay && heightDisplay){
    return `${widthDisplay} × ${heightDisplay}`;
  }
  if (widthDisplay && heightNumeric){
    return `${widthDisplay} × ${heightNumeric}`;
  }
  if (widthNumeric && heightDisplay){
    return `${widthNumeric} × ${heightDisplay}`;
  }
  if (widthNumeric && heightNumeric){
    return `${widthNumeric} × ${heightNumeric}`;
  }
  if (widthDisplay || widthNumeric){
    return `${widthDisplay || widthNumeric} × ?`;
  }
  if (heightDisplay || heightNumeric){
    return `? × ${heightDisplay || heightNumeric}`;
  }
  return "";
}

function sanitizeLabelRow(row){
  if (!row) return null;
  const quantitySources = [
    row.quantity, row.qty, row.Qty, row.QTY, row.qty_total, row.total_qty, row.qtyTotal
  ];
  let quantity = quantitySources.reduce((acc, value)=>{
    if (acc != null) return acc;
    if (value == null) return acc;
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : acc;
  }, null);
  if (!Number.isFinite(quantity) || quantity <= 0) quantity = 1;
  const orderNumber = [
    row.order_number, row.orderNumber, row.order_no, row.orderNo,
    row.order, row.orderId, row.order_id, row.orderLabel, row.order_label
  ].map(value => (value == null ? "" : String(value).trim())).find(value => value.length) || "";
  const type = (row.type || row.composition_display || row.composition_raw || row.glass_type || row.glassType || "").toString().trim();
  const dimension = deriveLabelDimension(row);
  const position = [
    row.position, row.position_label, row.positionLabel, row.pos, row.idx, row.index
  ].map(value => (value == null ? "" : String(value).trim())).find(value => value.length) || "";
  const areaValue = Number(row.area ?? row.computed_area ?? row.computedArea ?? 0);
  const area = Number.isFinite(areaValue) ? areaValue : 0;
  const client = [
    row.client, row.client_name, row.clientName, row.clientLabel, row.client_label, row.client_hint, row.customer
  ].map(value => (value == null ? "" : String(value).trim())).find(value => value.length) || "";
  return {
    order_number: orderNumber,
    type,
    dimension: dimension.length ? dimension : "—",
    position: position.length ? position : "—",
    quantity,
    area,
    client,
  };
}

function createLabelJob(source, rows, options = {}){
  if (!rows || !rows.length) return null;
  const normalized = rows.map(sanitizeLabelRow).filter(Boolean);
  if (!normalized.length) return null;
  const totals = computeTotals(normalized);
  const orders = collectOrderNumbers(normalized);
  const clientSet = new Set(normalized.map(row => row.client).filter(Boolean));
  const clientOverride = options.clientOverride && String(options.clientOverride).trim();
  const clientLabel = clientOverride || (clientSet.size === 1 ? Array.from(clientSet)[0] : (clientSet.size ? "(Mixed)" : "—"));
  const sourceLabel = options.sourceLabel || source;
  const job = {
    id: `lbl-${Date.now()}-${appState.labels.nextId++}`,
    source: sourceLabel,
    createdAt: new Date().toISOString(),
    rows: normalized,
    units: totals.units,
    labels: normalized.reduce((acc,row)=> acc + Number(row.quantity || 0), 0),
    area: totals.area,
    orders,
    clientLabel,
  };
  if (options.primaryOrderId){
    job.primaryOrderId = String(options.primaryOrderId);
    job.orderId = job.primaryOrderId;
    if (!job.orders.includes(job.primaryOrderId)){
      job.orders.unshift(job.primaryOrderId);
    }
  }
  if (options.sourceDetail){
    job.sourceDetail = options.sourceDetail;
  }
  return job;
}

function addLabelsJob(source, rows, options = {}){
  const job = createLabelJob(source, rows, options);
  if (!job){
    setLabelsStatus(options.emptyMessage || "No printable rows found.");
    return null;
  }
  appState.labels.jobs.unshift(job);
  const labelCount = Number(job.labels || job.units || 0);
  const labelWord = labelCount === 1 ? "label" : "labels";
  let message = "";
  if (typeof options.formatMessage === "function"){
    message = options.formatMessage(job);
  }
  if (!message){
    message = options.successMessage || `Added ${labelCount} ${labelWord} from ${source}.`;
  }
  setLabelsStatus(message);
  updateLabelsUI();
  return job;
}

function addLabelJobsFromProcessing(options = {}){
  const { silent = false } = options;
  const cart = appState.processing && Array.isArray(appState.processing.cart) ? appState.processing.cart : null;
  if (!cart){
    if (!silent) setLabelsStatus("Could not read Processing cart.");
    return null;
  }
  if (!cart.length){
    if (!silent) setLabelsStatus("Processing is empty.");
    return { addedJobs: [], skipped: [], totalRows: 0 };
  }

  const existingKeys = new Set(
    (appState.labels.jobs || [])
      .map(job => (job.primaryOrderId || (Array.isArray(job.orders) && job.orders[0]) || "").trim())
      .filter(Boolean)
  );

  const addedJobs = [];
  const skipped = [];
  let totalRows = 0;

  cart.forEach(entry => {
    if (!entry) return;
    const orderKeyRaw = entry.orderLabel || entry.orderId || entry.id;
    const orderKey = String(orderKeyRaw || "").trim();
    if (!orderKey){
      skipped.push("Unknown order");
      return;
    }
    if (existingKeys.has(orderKey)){
      skipped.push(orderKey);
      return;
    }
    const baseRows = Array.isArray(entry.rows) ? entry.rows : [];
    if (!baseRows.length){
      skipped.push(`${orderKey} (no rows)`);
      return;
    }
    const rowsWithClient = baseRows.map(row => ({
      ...row,
      client: row.client || entry.client || UNKNOWN_CLIENT_LABEL,
      orderId: row.orderId || orderKey,
    }));
    const job = createLabelJob("Processing", rowsWithClient, {
      primaryOrderId: orderKey,
      clientOverride: entry.client,
      sourceLabel: "Processing",
      sourceDetail: orderKey,
    });
    if (!job){
      skipped.push(orderKey);
      return;
    }
    addedJobs.push(job);
    existingKeys.add(orderKey);
    totalRows += Array.isArray(job.rows) ? job.rows.length : 0;
  });

  if (!addedJobs.length){
    const reason = skipped.length ? `Skipped: ${skipped.join(", ")}` : "No orders added.";
    if (!silent) setLabelsStatus(reason);
    return { addedJobs: [], skipped, totalRows: 0 };
  }

  addedJobs.reverse().forEach(job => appState.labels.jobs.unshift(job));
  updateLabelsUI();

  const skipNote = skipped.length ? ` Skipped: ${skipped.join(", ")}` : "";
  if (!silent){
    setLabelsStatus(`Added ${addedJobs.length} orders (${totalRows} rows) from Processing.${skipNote ? " " + skipNote : ""}`);
  }
  return { addedJobs, skipped, totalRows };
}

function updateLabelsSummary(){
  if (!labelsSummaryEl) return;
  const jobs = appState.labels.jobs || [];
  if (!jobs.length){
    labelsSummaryEl.innerHTML = "";
    return;
  }
  const totalLabels = jobs.reduce((acc, job)=> acc + Number(job.labels || job.units || 0), 0);
  const totalOrders = jobs.reduce((acc, job)=> acc + job.orders.length, 0);
  labelsSummaryEl.innerHTML = `<span class="pill">Jobs: ${jobs.length}</span> <span class="pill">Labels: ${totalLabels}</span> <span class="pill muted">Orders: ${totalOrders}</span>`;
}

function updateLabelsUI(){
  if (labelsFromProcessingBtn){
    const hasProcessing = !!(appState.processing.cart && appState.processing.cart.length);
    labelsFromProcessingBtn.disabled = !hasProcessing;
  }
  if (labelsFromProcessingDownloadBtn){
    const processingCount = appState.processing.cart ? appState.processing.cart.length : 0;
    labelsFromProcessingDownloadBtn.disabled = processingCount < 2;
  }
  if (labelsFromHistoryBtn){
    const hasHistory = !!(appState.historyDetail.rows && appState.historyDetail.rows.length);
    labelsFromHistoryBtn.disabled = !hasHistory;
  }
  if (labelsClearBtn){
    labelsClearBtn.disabled = !(appState.labels.jobs && appState.labels.jobs.length);
  }
  if (labelsJobsWrap){
    const jobs = appState.labels.jobs || [];
    if (!jobs.length){
      labelsJobsWrap.innerHTML = '<div class="labels-empty">No label jobs yet. Use the buttons above to add one.</div>';
    }else{
      let html = `<table><thead><tr>
        <th>#</th>
        <th>Created</th>
        <th>Source</th>
        <th>Orders</th>
        <th>Client</th>
        <th>Labels</th>
        <th>Preview</th>
        <th>Actions</th>
      </tr></thead><tbody>`;
      jobs.forEach((job, index)=>{
        const created = formatDate(job.createdAt);
        const orderSample = job.orders.slice(0,3).join(", ") || "—";
        const extraOrders = job.orders.length > 3 ? ` +${job.orders.length - 3}` : "";
        const previewRow = job.rows[0];
        const previewLines = [];
        if (previewRow){
          const previewOrder = previewRow.order_number || "—";
          const previewDim = previewRow.dimension || "—";
          previewLines.push(`<div class="muted small mono">${escapeHtml(previewOrder)} • ${escapeHtml(previewDim)}</div>`);
          previewLines.push(`<div class="muted small">${escapeHtml(previewRow.type || "—")} – Qty: ${previewRow.quantity}</div>`);
          if (job.rows.length > 1){
            previewLines.push(`<div class="muted small">+${job.rows.length - 1} more line(s)</div>`);
          }
        }
        html += `<tr>
          <td>${index + 1}</td>
          <td>${escapeHtml(created)}</td>
          <td>${escapeHtml(job.source || "—")}</td>
          <td>${escapeHtml(orderSample + extraOrders)}</td>
          <td>${escapeHtml(job.clientLabel || "—")}</td>
          <td>${Number(job.labels || job.units || 0)}</td>
          <td>${previewLines.join("") || "—"}</td>
          <td>
            <div style="display:flex;gap:6px;flex-wrap:wrap">
              <button class="btn small" data-action="labels-download" data-id="${escapeHtml(job.id)}">Download PDF</button>
              <button class="btn small muted" data-action="labels-remove" data-id="${escapeHtml(job.id)}">Remove</button>
            </div>
          </td>
        </tr>`;
      });
      html += "</tbody></table>";
      labelsJobsWrap.innerHTML = html;
    }
  }
  updateLabelsSummary();
}

async function sendOrderToProcessing(orderId){
  const order = await fetchOrder(orderId);
  if (!order || !order.rows || !order.rows.length){
    throw new Error("Order has no rows");
  }
  addOrderToProcessing(order);
  setStatusMessage("Order added to Processing.");
  activateTab("processing");
}

function syncProcessingHeaderEditor(){
  if (!processingHeaderSelect || processingHeaderSelect.disabled) return;
  const raw = processingHeaderSelect.value;
  const groups = appState.processing.preview.groups || [];
  const group = groups.find(item => item.raw === raw);
  if (!group){
    if (processingHeaderInput) processingHeaderInput.value = "";
    if (processingHeaderHint) processingHeaderHint.hidden = true;
    return;
  }
  const override = appState.processing.headerOverrides[raw] || "";
  if (processingHeaderInput) processingHeaderInput.value = override || group.display || "";
  if (processingHeaderHint){
    const invalidLines = group.lines.filter(line => line.invalid).length;
    if (invalidLines){
      processingHeaderHint.hidden = false;
      processingHeaderHint.textContent = `${invalidLines} line(s) have invalid dimensions in this group.`;
    }else{
      processingHeaderHint.hidden = true;
    }
  }
}

async function copyProcessingText(){
  const text = appState.processing.preview.text;
  if (!text){
    setStatusMessage("Nothing to copy.");
    return;
  }
  try{
    await navigator.clipboard.writeText(text);
    setStatusMessage("Mother Sheet copied to clipboard.");
  }catch(error){
    setStatusMessage("Copy failed: " + (error.message || error));
  }
}

async function exportProcessingPdf(){
  const preview = appState.processing.preview;
  if (!preview || !preview.groups || !preview.groups.length){
    setStatusMessage("Nothing to export.");
    return;
  }
  await ensurePdfLib();
  const { PDFDocument, StandardFonts } = PDFLib;
  const mmToPt = 2.83464567;
  const pdfDoc = await PDFDocument.create();
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  const regularFont = await pdfDoc.embedFont(StandardFonts.Helvetica);

  const TITLE_SIZE = 22;
  const HEADER_SIZE = 20;
  const BODY_SIZE = 14;
  const HEADER_LINE_HEIGHT = HEADER_SIZE * 1.4;
  const BODY_LINE_HEIGHT = BODY_SIZE * 1.6;
  const ORDER_LINE_HEIGHT = BODY_SIZE * 1.4;
  const HEADER_GAP_PT = 6;
  const GROUP_GAP_PT = 16;

  const pageWidth = 210 * mmToPt;
  const pageHeight = 297 * mmToPt;
  const marginLeft = 12 * mmToPt;
  const marginRight = 12 * mmToPt;
  const marginTop = 16 * mmToPt;
  const marginBottom = 16 * mmToPt;
  const contentWidth = pageWidth - marginLeft - marginRight;

  let page = pdfDoc.addPage([pageWidth, pageHeight]);
  let cursorY = pageHeight - marginTop;

  const wrapText = (text, font, size)=>{
    const words = String(text || "").split(/\s+/);
    const lines = [];
    let current = "";
    words.forEach(word => {
      const tentative = current ? `${current} ${word}` : word;
      const width = font.widthOfTextAtSize(tentative, size);
      if (width > contentWidth && current){
        lines.push(current);
        current = word;
      }else{
        current = tentative;
      }
    });
    if (current) lines.push(current);
    return lines.length ? lines : [""];
  };

  const ensureSpace = (requiredHeight = BODY_LINE_HEIGHT)=>{
    if (cursorY - requiredHeight < marginBottom){
      page = pdfDoc.addPage([pageWidth, pageHeight]);
      cursorY = pageHeight - marginTop;
    }
  };

  const drawTextBlock = (text, font, size, lineHeight, align = "left")=>{
    wrapText(text, font, size).forEach(line => {
      ensureSpace(lineHeight);
      let x = marginLeft;
      if (align === "center"){
        const lineWidth = font.widthOfTextAtSize(line, size);
        x = marginLeft + (contentWidth - lineWidth) / 2;
      }
      page.drawText(line, { x, y: cursorY, size, font });
      cursorY -= lineHeight;
    });
  };

  const drawBodyLine = (lineText)=>{
    drawTextBlock(lineText, regularFont, BODY_SIZE, BODY_LINE_HEIGHT);
  };

  const titleText = formatProcessingMeta(preview.meta || {});
  drawTextBlock(titleText, boldFont, TITLE_SIZE, TITLE_SIZE * 1.3, "left");
  cursorY -= 8;

  const groups = Array.isArray(preview.groups) ? preview.groups : [];
  const decimalSeparator = preview.meta?.decimalSeparator || appState.processing.options.decimalSeparator || "comma";

  groups.forEach((group, groupIndex) => {
    if (groupIndex > 0){
      cursorY -= GROUP_GAP_PT;
      ensureSpace();
    }
    const label = group && group.display ? group.display : "(Header not set)";
    const groupAreaValue = computeGroupArea(group?.lines || []);
    const groupAreaText = formatM2(groupAreaValue, decimalSeparator);
    const headerText = `${label} — Area: ${groupAreaText} m²`;
    drawTextBlock(headerText, boldFont, HEADER_SIZE, HEADER_LINE_HEIGHT);
    cursorY -= HEADER_GAP_PT;

    const sections = Array.isArray(group?.sections) ? group.sections : null;
    if (sections && sections.length){
      sections.forEach(section => {
        const orderLabel = section?.orderId ? String(section.orderId).trim() : "—";
        const clientLabel = section?.client ? String(section.client).trim() : UNKNOWN_CLIENT_LABEL;
        drawTextBlock(`[Order ${orderLabel} — ${clientLabel}]`, regularFont, BODY_SIZE, ORDER_LINE_HEIGHT);

        const lines = Array.isArray(section?.lines) ? section.lines : [];
        if (!lines.length){
          drawBodyLine("No line items.");
        }else{
          lines.forEach(line => {
            const idxText = line && line.idx != null ? String(line.idx) : "";
            const rounded = line?.danko;
            const widthText = formatProcessingNumber(line?.width, line?.widthDisplay, decimalSeparator);
            const heightText = formatProcessingNumber(line?.height, line?.heightDisplay, decimalSeparator);
            const qtyText = line && line.qty != null ? String(line.qty) : "";
            const caution = line?.invalid ? " ⚠" : "";
            const approx = rounded?.changed ? " ≈" : "";
            const message = `${idxText}  ${widthText} × ${heightText}${approx} × ${qtyText}${caution}`;
            drawBodyLine(message);
            if (rounded?.changed && rounded?.tooltip){
              drawBodyLine(`   (${rounded.tooltip})`);
            }
          });
        }
      });
    }else{
      const lines = Array.isArray(group?.lines) ? group.lines : [];
      if (!lines.length){
        drawBodyLine("No line items.");
      }else{
        lines.forEach(line => {
          const idxText = line && line.idx != null ? String(line.idx) : "";
          const widthText = formatProcessingNumber(line?.width, line?.widthDisplay, decimalSeparator);
          const heightText = formatProcessingNumber(line?.height, line?.heightDisplay, decimalSeparator);
          const qtyText = line && line.qty != null ? String(line.qty) : "";
          const caution = line?.invalid ? " ⚠" : "";
          const rounded = line?.danko;
          const approx = rounded?.changed ? " ≈" : "";
          drawBodyLine(`${idxText}  ${widthText} × ${heightText}${approx} × ${qtyText}${caution}`);
          if (rounded?.changed && rounded?.tooltip){
            drawBodyLine(`   (${rounded.tooltip})`);
          }
        });
      }
    }
  });

  const pdfBytes = await pdfDoc.save();
  const blob = new Blob([pdfBytes], { type: "application/pdf" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "mother-sheet.pdf";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  setStatusMessage("Mother Sheet PDF exported.");
}

function exportProcessingCsv(){
  const rowsData = Array.isArray(appState.processing.rows) ? appState.processing.rows : [];
  if (!rowsData.length){
    setStatusMessage("Nothing to export.");
    return;
  }
  const header = ["nr","width","height","qty","composition_display","composition_raw","orderId","client"];
  const rows = [header];
  const separator = appState.processing.options.decimalSeparator;
  rowsData.forEach((row, index) => {
    const original = row.__original || {};
    const widthText = formatProcessingNumber(original.width, original.widthDisplay, separator);
    const heightText = formatProcessingNumber(original.height, original.heightDisplay, separator);
    const compositionRaw = row.composition_raw || "";
    const compositionDisplay = normalizeHeaderForDisplay(compositionRaw, appState.processing.options.normalizeLPtoG);
    rows.push([
      index + 1,
      widthText,
      heightText,
      row.qty ?? "",
      compositionDisplay || compositionRaw,
      compositionRaw,
      row.orderId || "",
      row.client || "",
    ]);
  });
  const csv = rows.map(columns => columns.map(value => {
    const text = String(value ?? "");
    if (/[",\n]/.test(text)){
      return `"${text.replace(/"/g, '""')}"`;
    }
    return text;
  }).join(",")).join("\n");
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "mother-sheet.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  setStatusMessage("Mother Sheet CSV exported.");
}

function renderWarningList(containerId, warnings){
  const container = typeof containerId === "string" ? document.getElementById(containerId) : containerId;
  if (!container) return;
  const list = container.querySelector("ul");
  const items = Array.isArray(warnings) ? warnings.filter(Boolean) : [];
  if (!items.length){
    container.hidden = true;
    if (list) list.innerHTML = "";
    return;
  }
  container.hidden = false;
  if (list){
    list.innerHTML = items.map(item => `<li>${escapeHtml(item)}</li>`).join("");
  }
}

const cssEscape = (window.CSS && typeof window.CSS.escape === "function")
  ? window.CSS.escape.bind(window.CSS)
  : (value) => String(value).replace(/["\\#.;]/g, "\\$&");

function withPreservedFocus(callback, options = {}){
  const { focusKey: explicitKey = null, selection: explicitSelection = null } = options;
  const active = document.activeElement;
  const isEditable = active && active.classList && active.classList.contains("cell") && active.dataset.key;
  let focusKey = explicitKey;
  let selectionRange = explicitSelection;
  if (isEditable && !focusKey){
    focusKey = active.dataset.key;
    selectionRange = [active.selectionStart ?? active.value.length, active.selectionEnd ?? active.value.length];
  }
  const scrollY = window.scrollY;
  callback();
  window.scrollTo(0, scrollY);
  if (focusKey){
    const selector = `[data-key="${cssEscape(focusKey)}"]`;
    const next = document.querySelector(selector);
    if (next){
      next.focus();
      if (selectionRange && typeof next.setSelectionRange === "function"){
        next.setSelectionRange(selectionRange[0], selectionRange[1]);
      }
    }
  }
}

function parseDim(dim){
  const match = (dim || "").trim().match(/^(\d{2,4})\s*[xX×]\s*(\d{2,4})$/);
  return match ? [Number(match[1]), Number(match[2])] : null;
}

function areaFromDim(dim){
  const parsed = parseDim(dim);
  if (!parsed) return null;
  const [w, h] = parsed;
  return Math.round(((w * h) / 1_000_000) * 1000) / 1000;
}

function cleanPosKey(position){
  if (!position) return [0, 0, ""];
  const [main, suffix = ""] = position.split("/");
  const [first, second] = (main || "").split("-");
  return [Number(first) || 0, Number(second) || 0, suffix];
}

function nextPositionForGroup(rows, order){
  const list = rows.filter(r => (r.order_number || "") === order);
  const maxFirst = Math.max(0, ...list.map(r => Number((r.position || "").split("-")[0]) || 0));
  return `${maxFirst + 1}-1`;
}

function recalcParsedTotals(bucket){
  const totals = computeTotals(bucket.rows || []);
  bucket.parsedUnits = totals.units;
  bucket.parsedArea = totals.area;
}

function addRowToGroup(scope, order){
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  const rows = bucket.rows ? [...bucket.rows] : [];
  const targetOrder = order || "";
  const template = rows.filter(r => (r.order_number || "") === targetOrder);
  const fallback = template.length ? template[template.length - 1] : rows[rows.length - 1] || {};
  const rid = `${scope}-new-${bucket.nextRid++}`;
  const newRow = {
    order_number: targetOrder,
    type: fallback?.type || "",
    dimension: "",
    position: nextPositionForGroup(rows, targetOrder),
    quantity: 1,
    area: 0,
    computed_area: null,
    area_mismatch: null,
    _rid: rid,
  };
  rows.push(newRow);
  rows.sort((a, b) => {
    const orderCmp = (a.order_number || "").localeCompare(b.order_number || "");
    if (orderCmp !== 0) return orderCmp;
    const keyA = cleanPosKey(a.position || "0-0");
    const keyB = cleanPosKey(b.position || "0-0");
    if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
    if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
    return keyA[2].localeCompare(keyB[2]);
  });
  bucket.rows = rows;
  bucket.rowWarnings = bucket.rowWarnings || {};
  bucket.rowWarnings[newRow._rid] = [];
  recalcParsedTotals(bucket);
  if (scope === "history"){
    updateHistoryDetailUI();
  }else{
    updateExtractUI();
  }
}

function fixAreaForRow(scope, index){
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  const rows = bucket.rows || [];
  const row = rows[index];
  if (!row) return;
  const computed = typeof row.computed_area === "number" ? row.computed_area : areaFromDim(row.dimension);
  if (computed == null) return;
  row.area = computed;
  row.computed_area = computed;
  row.area_mismatch = false;
  if (bucket.rowWarnings && row._rid && bucket.rowWarnings[row._rid]){
    bucket.rowWarnings[row._rid] = bucket.rowWarnings[row._rid].filter(item => !item.includes("area"));
  }
  recalcParsedTotals(bucket);
  if (scope === "history"){
    updateHistoryDetailUI();
  }else{
    updateExtractUI();
  }
}

function fixAllAreas(scope){
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  let changed = false;
  (bucket.rows || []).forEach((row, idx) => {
    const computed = typeof row.computed_area === "number" ? row.computed_area : areaFromDim(row.dimension);
    if (computed != null && Math.abs(Number(row.area || 0) - computed) > 0.01){
      row.area = computed;
      row.computed_area = computed;
      row.area_mismatch = false;
      if (bucket.rowWarnings && row._rid && bucket.rowWarnings[row._rid]){
        bucket.rowWarnings[row._rid] = bucket.rowWarnings[row._rid].filter(item => !item.includes("area"));
      }
      changed = true;
    }
  });
  if (!changed) return;
  recalcParsedTotals(bucket);
  if (scope === "history"){
    updateHistoryDetailUI();
  }else{
    updateExtractUI();
  }
}

function renderEditableTable(scope, containerId, rows, rowWarnings){
  const container = typeof containerId === "string" ? document.getElementById(containerId) : containerId;
  if (!container) return;
  if (!Array.isArray(rows) || !rows.length){
    container.innerHTML = '<div class="empty-state">No rows yet — run an extraction.</div>';
    return;
  }
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  const indexMap = new Map((bucket.rows || []).map((row, idx) => [row._rid || `rid-${idx}`, idx]));
  const groups = summarizeByOrder(rows);
  let globalIndex = 0;
  let html = "";
  for (const [order, items] of groups.entries()){
    const orderLabel = order || "—";
    html += `<div class="group-header" data-order="${escapeHtml(order)}" style="display:flex;justify-content:space-between;align-items:center;margin:16px 0 6px">
      <div style="font-weight:600">${orderLabel}</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button type="button" class="btn small" data-add-row="${escapeHtml(order)}">Add row</button>
      </div>
    </div>`;
    html += `<table class="editable-table" data-order="${escapeHtml(order)}">
      <thead>
        <tr>
          <th>#</th>
          <th>Warnings</th>
          <th>Order</th>
          <th>Type</th>
          <th>Dimension</th>
          <th>Position</th>
          <th>Quantity</th>
          <th>Area (m²)</th>
          <th></th>
        </tr>
      </thead>
      <tbody>`;
    items.forEach(row => {
      if (!row._rid){
        row._rid = `${scope}-${Date.now()}-${globalIndex}`;
      }
      const rowIndex = indexMap.has(row._rid) ? indexMap.get(row._rid) : globalIndex;
      const warns = rowWarnings && rowWarnings[row._rid] ? rowWarnings[row._rid] : [];
      const hasSplit = warns.some(w => w.includes("possible_split_line"));
      const warningBadges = [];
      if (hasSplit){
        warningBadges.push('<span class="editable-badge" title="Possible split line; please fix dimension/position wrap">⚠️</span>');
      }
      const computed = typeof row.computed_area === "number" ? row.computed_area : areaFromDim(row.dimension);
      const providedArea = Number(row.area || 0);
      const mismatch = computed != null && Math.abs(providedArea - computed) > 0.01;
      if (mismatch){
        const delta = (providedArea - computed).toFixed(3);
        warningBadges.push(`<span class="pill warn" title="Provided ${providedArea.toFixed(3)} vs computed ${computed.toFixed(3)}">Δ ${delta} m²</span>`);
      }
      const otherWarnings = warns.filter(w => !w.includes("possible_split_line"));
      if (otherWarnings.length){
        warningBadges.push(`<span class="editable-badge" title="${escapeHtml(otherWarnings.join('; '))}">!</span>`);
      }
      const warningBadge = warningBadges.join(" ");
      const inputBase = `data-scope="${scope}" data-index="${rowIndex}" autocomplete="off" class="cell"`;
      const orderKey = `${row._rid}:order_number`;
      const typeKey = `${row._rid}:type`;
      const dimKey = `${row._rid}:dimension`;
      const posKey = `${row._rid}:position`;
      const qtyKey = `${row._rid}:quantity`;
      const areaKey = `${row._rid}:area`;
      const fixBtn = mismatch ? `<button type="button" class="btn small" data-fix-area="${rowIndex}" title="Set area to ${computed?.toFixed(3) ?? ''}">Fix</button>` : "";
      html += `<tr data-index="${rowIndex}" data-order="${escapeHtml(order)}">
        <td>${globalIndex + 1}</td>
        <td>${warningBadge}</td>
        <td><input ${inputBase} data-field="order_number" data-key="${orderKey}" value="${escapeHtml(row.order_number || "")}" /></td>
        <td><input ${inputBase} data-field="type" data-key="${typeKey}" value="${escapeHtml(row.type || "")}" /></td>
        <td><input ${inputBase} data-field="dimension" data-key="${dimKey}" inputmode="text" value="${escapeHtml(row.dimension || "")}" /></td>
        <td><input ${inputBase} data-field="position" data-key="${posKey}" inputmode="text" value="${escapeHtml(row.position || "")}" /></td>
        <td><input ${inputBase} data-field="quantity" data-key="${qtyKey}" type="number" inputmode="numeric" min="0" step="1" value="${escapeHtml(row.quantity ?? 0)}" /></td>
        <td><input ${inputBase} data-field="area" data-key="${areaKey}" type="number" inputmode="decimal" min="0" step="0.001" value="${escapeHtml(row.area ?? 0)}" /></td>
        <td>${fixBtn}</td>
      </tr>`;
      globalIndex += 1;
    });
    html += "</tbody></table>";
  }
  container.innerHTML = html;
}

function parseFieldValue(field, rawValue){
  if (field === "quantity"){
    const parsed = parseInt(rawValue, 10);
    return Number.isFinite(parsed) ? parsed : 0;
  }
  if (field === "area"){
    const parsed = parseFloat(rawValue);
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return rawValue ?? "";
}

function updateRowValue(scope, index, field, value, options = {}){
  const { commit = false } = options;
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  const row = bucket.rows[index];
  if (!row) return;
  bucket.rows[index][field] = value;
  const rid = row._rid;
  if (bucket.rowWarnings && rid){
    delete bucket.rowWarnings[rid];
  }
  if (field === "dimension" || field === "area"){
    const computed = areaFromDim(row.dimension);
    row.computed_area = computed;
    if (computed != null){
      row.area_mismatch = Math.abs(Number(row.area || 0) - computed) > 0.01;
    }else{
      row.area_mismatch = null;
    }
  }
  if (field === "quantity"){
    row.quantity = Math.max(0, Number(row.quantity || 0));
  }
  if (scope === "extract"){
    window.__rows = bucket.rows;
  }
  if (commit){
    recalcParsedTotals(bucket);
    if (scope === "history"){
      updateHistoryDetailUI();
    }else{
      updateExtractUI();
    }
  }else{
    updateTotalsUI(scope);
  }
}

function handleEditableInput(event){
  const input = event.target;
  if (!input.classList.contains("cell")) return;
  const field = input.dataset.field;
  const scope = input.dataset.scope;
  const index = Number(input.dataset.index);
  if (!field || !scope || Number.isNaN(index)) return;
  const parsed = parseFieldValue(field, input.value);
  updateRowValue(scope, index, field, parsed, { commit: false });
}

document.getElementById("tableWrap").addEventListener("input", handleEditableInput, true);
document.getElementById("historyTableWrap").addEventListener("input", handleEditableInput, true);
document.getElementById("extractNotes").addEventListener("input", (event)=>{
  appState.extract.notes = event.target.value;
});
document.getElementById("historyNotes").addEventListener("input", (event)=>{
  appState.historyDetail.notes = event.target.value;
});

document.getElementById("tableWrap").addEventListener("click", (event)=>{
  const addBtn = event.target.closest("[data-add-row]");
  if (addBtn){
    addRowToGroup("extract", addBtn.dataset.addRow || "");
    return;
  }
  const fixBtn = event.target.closest("[data-fix-area]");
  if (fixBtn){
    const idx = Number(fixBtn.dataset.fixArea);
    if (!Number.isNaN(idx)) fixAreaForRow("extract", idx);
  }
});

document.getElementById("historyTableWrap").addEventListener("click", (event)=>{
  const addBtn = event.target.closest("[data-add-row]");
  if (addBtn){
    addRowToGroup("history", addBtn.dataset.addRow || "");
    return;
  }
  const fixBtn = event.target.closest("[data-fix-area]");
  if (fixBtn){
    const idx = Number(fixBtn.dataset.fixArea);
    if (!Number.isNaN(idx)) fixAreaForRow("history", idx);
  }
});

const fixAllAreasBtn = document.getElementById("fixAllAreas");
if (fixAllAreasBtn){
  fixAllAreasBtn.addEventListener("click", ()=> fixAllAreas("extract"));
}
const historyFixAllAreasBtn = document.getElementById("historyFixAllAreas");
if (historyFixAllAreasBtn){
  historyFixAllAreasBtn.addEventListener("click", ()=> fixAllAreas("history"));
}

function normalizeDimensionInput(value){
  if (!value) return "";
  return value
    .replace(/[×X]/g, "x")
    .replace(/\s+/g, "")
    .replace(/x+/g, "x");
}

function handleEditableBlur(event){
  const input = event.target;
  if (!input.classList.contains("cell")) return;
  const field = input.dataset.field;
  const scope = input.dataset.scope;
  const index = Number(input.dataset.index);
  if (!field || !scope || Number.isNaN(index)) return;
  let value = input.value;
  if (field === "dimension"){
    value = normalizeDimensionInput(value);
    input.value = value;
  }else if (field === "position"){
    value = value.trim();
    input.value = value;
  }else if (field === "quantity"){
    const parsedQty = parseInt(value, 10);
    value = Number.isFinite(parsedQty) ? String(parsedQty) : "0";
    input.value = value;
  }else if (field === "area"){
    const parsedArea = parseFloat(value);
    value = Number.isFinite(parsedArea) ? parsedArea.toFixed(3) : "0.000";
    input.value = value;
  }
  const parsed = parseFieldValue(field, value);
  updateRowValue(scope, index, field, parsed, { commit: true });
}

document.getElementById("tableWrap").addEventListener("blur", handleEditableBlur, true);
document.getElementById("historyTableWrap").addEventListener("blur", handleEditableBlur, true);

function setErrorMessage(msg){
  if (!msg){
    errorEl.hidden = true;
    errorEl.textContent = "";
  }else{
    errorEl.hidden = false;
    errorEl.textContent = msg;
  }
}

function setHistoryStatus(msg){
  historyStatusEl.textContent = msg || "";
}

function updateHistoryOfflineBadge(){
  historyOfflineBadge.hidden = !historyState.offline;
}

function formatDate(value){
  if (!value) return "—";
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return value;
  return date.toLocaleString([], { dateStyle: "short", timeStyle: "short" });
}

function formatArea(value){
  const num = Number(value || 0);
  return num.toFixed(3);
}

// --- CSV + grouping helpers -------------------------------------------------
function groupWithinOrders(rows){
  const keyOf = (r) => `${(r.order_number||"").trim()}|${(r.type||"").trim()}|${(r.dimension||"").trim()}`;
  const map = new Map();
  for(const r of rows){
    const key = keyOf(r);
    if (!map.has(key)){
      map.set(key, {
        order_number: (r.order_number||"").trim(),
        type: r.type || "",
        dimension: r.dimension || "",
        position: "— (grouped)",
        quantity: 0,
        area: 0
      });
    }
    const agg = map.get(key);
    const qty = Number(r.quantity || 0);
    const area = Number(r.area || 0);
    agg.quantity += qty;
    agg.area += area;
  }
  return Array.from(map.values());
}

function toCSV(rows){
  const header = ["order_number","type","dimension","position","quantity","area"];
  const out = [header.join(",")];
  for(const r of rows){
    const vals = header.map(key=>{
      let value = r[key];
      if (typeof value === "string"){
        if (value.includes(",") || value.includes("\"")){
          value = "\"" + value.replace(/"/g, "\"\"") + "\"";
        }
      }
      return value;
    });
    out.push(vals.join(","));
  }
  return out.join("\n");
}

function summarizeByOrder(rows){
  const map = new Map();
  for(const r of rows){
    const key = (r.order_number || "").trim();
    if (!map.has(key)) map.set(key, []);
    map.get(key).push(r);
  }
  return map;
}

function computeTotals(rows){
  const units = rows.reduce((acc,row)=> acc + Number(row.quantity || 0), 0);
  const area = rows.reduce((acc,row)=> acc + Number(row.area || 0), 0);
  return { units, area };
}

function collectOrderNumbers(rows){
  return Array.from(new Set(rows.map(row => (row.order_number || "").trim()).filter(Boolean)));
}

function updateExtractSummary(){
  const rows = appState.extract.rows || [];
  const totals = computeTotals(rows);
  const orderNumbers = collectOrderNumbers(rows);
  const summaryEl = document.getElementById("summary");
  const orderInfoEl = document.getElementById("orderInfo");
  if (summaryEl){
    if (!rows.length){
      summaryEl.textContent = "";
    }else{
      summaryEl.innerHTML = `Totals — <span class="pill">Units: ${totals.units}</span> <span class="pill">Area: ${formatArea(totals.area)} m²</span>`;
    }
  }
  if (orderInfoEl){
    const parts = [];
    if (appState.extract.draftId){
      parts.push(`Draft #${appState.extract.draftId}`);
    }
    if (!appState.extract.draftId && appState.extract.savedOrderId){
      parts.push(`Saved #${appState.extract.savedOrderId}`);
    }
    if (!orderNumbers.length){
      parts.push("Order not detected");
    }else if (orderNumbers.length === 1){
      parts.push(`Order: ${orderNumbers[0]}`);
    }else{
      parts.push(`Orders: ${orderNumbers.join(", ")}`);
    }
    orderInfoEl.textContent = parts.join(" • ");
  }
}

function updateHistorySummary(){
  const rows = appState.historyDetail.rows || [];
  const totals = computeTotals(rows);
  const orderNumbers = collectOrderNumbers(rows);
  const summaryEl = document.getElementById("historySummary");
  const orderInfoEl = document.getElementById("historyOrderInfo");
  if (summaryEl){
    if (!rows.length){
      summaryEl.textContent = "";
    }else{
      summaryEl.innerHTML = `Totals — <span class="pill">Units: ${totals.units}</span> <span class="pill">Area: ${formatArea(totals.area)} m²</span>`;
    }
  }
  if (orderInfoEl){
    if (!orderNumbers.length){
      orderInfoEl.textContent = "Order not detected";
    }else if (orderNumbers.length === 1){
      orderInfoEl.textContent = `Order: ${orderNumbers[0]}`;
    }else{
      orderInfoEl.textContent = `Orders: ${orderNumbers.join(", ")}`;
    }
  }
}

function updateDeclaredBanner(elementId, declaredUnits, declaredArea, parsedUnits, parsedArea){
  const el = document.getElementById(elementId);
  if (!el) return;
  const issues = [];
  if (declaredUnits != null && parsedUnits != null && declaredUnits !== parsedUnits){
    issues.push(`Declared ${declaredUnits}, Parsed ${parsedUnits}`);
  }
  if (
    declaredArea != null && parsedArea != null &&
    Math.abs(parseFloat(declaredArea) - parseFloat(parsedArea)) > 0.05
  ){
    const delta = (parseFloat(parsedArea) - parseFloat(declaredArea)).toFixed(3);
    issues.push(`Declared ${Number(declaredArea).toFixed(3)} m², Parsed ${Number(parsedArea).toFixed(3)} m² → Δ ${delta} m²`);
  }
  if (!issues.length){
    el.hidden = true;
    el.innerHTML = "";
    return;
  }
  el.hidden = false;
  el.innerHTML = `<strong style="display:block;margin-bottom:4px">Declared totals mismatch</strong><div>${issues.map(escapeHtml).join('<br>')}</div>`;
}

function updateExtractUI(){
  withPreservedFocus(() => {
    const groupToggleEl = document.getElementById("groupToggle");
    if (groupToggleEl){
      groupToggleEl.disabled = false;
      if (groupToggleEl.checked !== groupState){
        groupToggleEl.checked = groupState;
      }
    }

    recalcParsedTotals(appState.extract);

    if (groupState){
      render(appState.extract.rows, { scope: "extract" });
    }else{
      renderEditableTable("extract", "tableWrap", appState.extract.rows, appState.extract.rowWarnings || {});
    }

    renderWarningList("extractWarnings", appState.extract.warnings);
    updateTotalsUI("extract");

    const approveBtn = document.getElementById("approveSave");
    if (approveBtn) approveBtn.disabled = !appState.extract.draftId || !(appState.extract.rows && appState.extract.rows.length);
    const rerunBtn = document.getElementById("rerun");
    if (rerunBtn) rerunBtn.disabled = !appState.extract.draftId;
    const notesEl = document.getElementById("extractNotes");
    if (notesEl && notesEl.value !== appState.extract.notes){
      notesEl.value = appState.extract.notes || "";
    }
  });
  window.__rows = appState.extract.rows;
  updateLabelsUI();
}

function buildSummaryHtml(rows, totalsParam){
  const totals = totalsParam || computeTotals(rows);
  const groups = summarizeByOrder(rows);
  let html = `Totals — <span class="pill">Units: ${totals.units}</span> <span class="pill">Area: ${formatArea(totals.area)} m²</span>`;
  if (groups.size > 1){
    const orderList = [...groups.keys()].filter(Boolean);
    if (orderList.length){
      html += ` <span class="muted small">Multiple orders: ${orderList.join(", ")}</span>`;
    }
  }
  return html;
}

function updateOrderInfo(scope){
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  const rows = bucket.rows || [];
  const orderNumbers = collectOrderNumbers(rows);
  const targetId = scope === "history" ? "historyOrderInfo" : "orderInfo";
  const el = document.getElementById(targetId);
  if (!el) return;
  const pieces = [];
  if (!orderNumbers.length){
    pieces.push("Order number not detected.");
  }else if (orderNumbers.length === 1){
    pieces.push(`Order: ${orderNumbers[0]}`);
  }else{
    pieces.push(`Orders: ${orderNumbers.join(", ")}`);
  }
  const clientName = scope === "history"
    ? (historyState.selectedOrder && (historyState.selectedOrder.client || historyState.selectedOrder.client_hint))
    : appState.extract.client;
  pieces.push(`Client: ${(clientName && clientName.trim()) ? clientName : "—"}`);
  el.textContent = pieces.join(" • ");
}

function updateTotalsUI(scope){
  const bucket = scope === "history" ? appState.historyDetail : appState.extract;
  const rows = bucket.rows || [];
  const summaryId = scope === "history" ? "historySummary" : "summary";
  const summaryEl = document.getElementById(summaryId);
  const totals = computeTotals(rows);
  if (summaryEl){
    summaryEl.innerHTML = buildSummaryHtml(rows, totals);
  }
  bucket.parsedUnits = totals.units;
  bucket.parsedArea = totals.area;
  if (scope === "history"){
    updateDeclaredBanner("historyDeclaredBanner", bucket.declaredUnits, bucket.declaredArea, bucket.parsedUnits, bucket.parsedArea);
  }else{
    updateDeclaredBanner("declaredBanner", bucket.declaredUnits, bucket.declaredArea, bucket.parsedUnits, bucket.parsedArea);
  }
  updateOrderInfo(scope);
  updateFixAllState(scope);
}

function updateFixAllState(scope){
  if (scope === "history"){
    const btn = document.getElementById("historyFixAllAreas");
    if (!btn) return;
    const order = appState.historyDetail.order;
    const status = (order && order.status || "").toLowerCase();
    const mismatchCount = (appState.historyDetail.rows || []).filter(row => {
      const computed = typeof row.computed_area === "number" ? row.computed_area : areaFromDim(row.dimension);
      if (computed == null) return false;
      return Math.abs(Number(row.area || 0) - computed) > 0.01;
    }).length;
    btn.hidden = status !== "draft" || mismatchCount === 0;
  }else{
    const btn = document.getElementById("fixAllAreas");
    if (!btn) return;
    const mismatchCount = (appState.extract.rows || []).filter(row => {
      const computed = typeof row.computed_area === "number" ? row.computed_area : areaFromDim(row.dimension);
      if (computed == null) return false;
      return Math.abs(Number(row.area || 0) - computed) > 0.01;
    }).length;
    btn.hidden = groupState || mismatchCount === 0;
  }
}

function updateHistoryDetailUI(){
  withPreservedFocus(() => {
    const container = document.getElementById("historyTableWrap");
    const empty = document.getElementById("historyDetailEmpty");
    const approveBtn = document.getElementById("historyApprove");
    const order = appState.historyDetail.order;
    recalcParsedTotals(appState.historyDetail);
    const fixAllBtn = document.getElementById("historyFixAllAreas");
    if (!appState.historyDetail.order){
      if (container) container.innerHTML = "";
      renderWarningList("historyWarnings", []);
      updateDeclaredBanner("historyDeclaredBanner", null, null, null, null);
      if (approveBtn) approveBtn.disabled = true;
      if (empty) empty.style.display = "block";
      historyPrintBtn.disabled = true;
      historyCsvBtn.disabled = true;
      if (historyProcessingBtn) historyProcessingBtn.disabled = true;
      historyMetaEl.textContent = "";
      if (fixAllBtn) fixAllBtn.hidden = true;
      updateTotalsUI("history");
      return;
    }
    const status = (order.status || "").toLowerCase();
    const clientName = order.client || order.client_hint || "—";
    const client = `Client: ${clientName}`;
    const metaPieces = [formatDate(order.created_at), client, `Source: ${order.source || "—"}`, `Status: ${status || "unknown"}`];
    historyMetaEl.textContent = metaPieces.join(" • ");
    historyPrintBtn.disabled = !(order.rows && order.rows.length);
    historyCsvBtn.disabled = status !== "approved";
    if (historyProcessingBtn) historyProcessingBtn.disabled = !(order.rows && order.rows.length);
    if (status === "draft"){
      renderEditableTable("history", "historyTableWrap", appState.historyDetail.rows, appState.historyDetail.rowWarnings || {});
      if (approveBtn) approveBtn.disabled = !(appState.historyDetail.rows && appState.historyDetail.rows.length);
      const toggle = document.getElementById("historyGroupToggle");
      if (toggle){
        toggle.checked = false;
        toggle.disabled = true;
      }
    }else{
      render(appState.historyDetail.rows, { scope: "history" });
      if (approveBtn) approveBtn.disabled = true;
      const toggle = document.getElementById("historyGroupToggle");
      if (toggle) toggle.disabled = false;
      if (!appState.historyDetail.rows || !appState.historyDetail.rows.length){
        if (container) container.innerHTML = '<div class="empty-state">No rows saved for this order.</div>';
      }
    }
    renderWarningList("historyWarnings", appState.historyDetail.warnings);
    updateTotalsUI("history");
    const notesEl = document.getElementById("historyNotes");
    if (notesEl && notesEl.value !== appState.historyDetail.notes){
      notesEl.value = appState.historyDetail.notes || "";
    }
    if (empty) empty.style.display = "none";
  });
  updateLabelsUI();
}

function render(rows, opts={}){
  const scope = opts.scope || "extract";
  if (!(scope in renderTargets)) return;
  if (rows === undefined || rows === null){
    rows = renderState[scope].rows || [];
  }else{
    renderState[scope].rows = Array.isArray(rows) ? rows : [];
  }
  const sourceRows = Array.isArray(rows) ? rows : [];
  const useGrouped = groupState;
  const rowsForView = useGrouped ? groupWithinOrders(sourceRows) : sourceRows;
  renderState[scope].displayed = rowsForView;

  const target = renderTargets[scope];
  const tableWrap = document.getElementById(target.tableId);
  const summaryEl = document.getElementById(target.summaryId);
  const orderInfoEl = document.getElementById(target.orderInfoId);

  if (!tableWrap) return;

  if (!sourceRows.length){
    tableWrap.innerHTML = "";
    if (summaryEl) summaryEl.textContent = "";
    if (orderInfoEl) orderInfoEl.textContent = "";
    return;
  }

  const groups = summarizeByOrder(rowsForView);
  const orderList = [...groups.keys()].filter(Boolean);
  const totals = computeTotals(rowsForView);

  if (summaryEl){
    let html = `Totals — <span class="pill">Units: ${totals.units}</span> <span class="pill">Area: ${formatArea(totals.area)} m²</span>`;
    if (groups.size > 1){
      html += `<span class="muted small">Multiple orders: ${orderList.join(", ")}</span>`;
    }
    summaryEl.innerHTML = html;
  }

  if (orderInfoEl){
    if (!orderList.length){
      orderInfoEl.textContent = "Order number not detected.";
    }else if (orderList.length === 1){
      orderInfoEl.textContent = `Order: ${orderList[0]}`;
    }else{
      orderInfoEl.textContent = `Orders: ${orderList.join(", ")}`;
    }
  }

  let html = "";
  for(const [order, rowsForOrder] of groups.entries()){
    const total = computeTotals(rowsForOrder);
    if (groups.size > 1){
      html += `<div style="padding:12px 14px"><div style="font-weight:600">${order || "No order number"}</div><div class="muted small">Units: ${total.units} • Area: ${formatArea(total.area)} m²</div></div>`;
    }
    html += `<table><thead><tr>
      <th>#</th>
      <th>Order</th>
      <th>Type</th>
      <th>Dimension</th>
      <th>Position</th>
      <th>Quantity</th>
      <th>Area (m²)</th>
    </tr></thead><tbody>`;
    rowsForOrder.forEach((row, idx)=>{
      html += `<tr>
        <td>${idx + 1}</td>
        <td class="mono">${row.order_number || ""}</td>
        <td>${row.type || ""}</td>
        <td class="mono">${row.dimension ? row.dimension : "—"}</td>
        <td class="mono">${row.position || ""}</td>
        <td>${row.quantity}</td>
        <td>${formatArea(row.area)}</td>
      </tr>`;
    });
    html += "</tbody></table>";
  }
  tableWrap.innerHTML = html;
}

function getDisplayedRows(scope="extract"){
  if (scope === "extract"){
    if (groupState){
      return groupWithinOrders(appState.extract.rows || []);
    }
    return appState.extract.rows || [];
  }
  if (scope === "history"){
    const status = (appState.historyDetail.order && appState.historyDetail.order.status || "").toLowerCase();
    if (status === "draft"){
      return appState.historyDetail.rows || [];
    }
    if (groupState){
      return groupWithinOrders(appState.historyDetail.rows || []);
    }
    const state = renderState[scope];
    if (state && state.displayed && state.displayed.length) return state.displayed;
    return appState.historyDetail.rows || [];
  }
  return [];
}

function ensureHistoryLoaded(){
  if (historyState.loading){
    return historyState.loadingPromise;
  }
  if (!historyState.loadedOnce || historyState.needsRefresh){
    historyState.loadingPromise = loadHistory({ resetOffset: historyState.needsRefresh });
    return historyState.loadingPromise;
  }
  return Promise.resolve();
}

function readHistoryCache(){
  try{
    const raw = localStorage.getItem(HISTORY_CACHE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  }catch{
    return [];
  }
}

function writeHistoryCache(items){
  try{
    localStorage.setItem(HISTORY_CACHE_KEY, JSON.stringify(items));
  }catch{
    /* ignore quota errors */
  }
}

function updateHistoryCache(newItems){
  const map = new Map();
  const merged = [...newItems, ...readHistoryCache()];
  merged.forEach(item=>{
    if (!item || typeof item.id === "undefined") return;
    map.set(item.id, item);
  });
  const sorted = Array.from(map.values()).sort((a,b)=>{
    const da = new Date(a.created_at || 0).getTime();
    const db = new Date(b.created_at || 0).getTime();
    return db - da;
  });
  writeHistoryCache(sorted.slice(0, HISTORY_CACHE_LIMIT));
}

function removeFromHistoryCache(id){
  const idKey = String(id);
  const filtered = readHistoryCache().filter(item => String(item.id) !== idKey);
  writeHistoryCache(filtered);
}

async function fetchOrders(params){
  const search = new URLSearchParams();
  if (params.limit) search.set("limit", String(params.limit));
  if (params.offset) search.set("offset", String(params.offset));
  if (params.query) search.set("query", params.query);
  if (params.status) search.set("status", params.status);
  const url = API_BASE + "/orders" + (search.toString() ? "?" + search.toString() : "");
  const res = await fetch(url);
  if (!res.ok){
    const text = await res.text();
    throw new Error(text || ("HTTP " + res.status));
  }
  return res.json();
}

async function fetchOrder(id){
  const res = await fetch(API_BASE + "/orders/" + id);
  if (!res.ok){
    const text = await res.text();
    throw new Error(text || ("HTTP " + res.status));
  }
  return res.json();
}

async function deleteOrder(id){
  const numericId = Number(id);
  const pathId = Number.isFinite(numericId) ? String(numericId) : encodeURIComponent(String(id));
  const res = await fetch(API_BASE + "/orders/" + pathId, { method: "DELETE" });
  if (!res.ok){
    const text = await res.text();
    throw new Error(text || ("HTTP " + res.status));
  }
}

async function downloadOrderCsv(id){
  const res = await fetch(API_BASE + "/orders/" + id + "/csv");
  if (!res.ok){
    const text = await res.text();
    throw new Error(text || ("HTTP " + res.status));
  }
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "order-" + id + ".csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function downloadAllCsv(){
  const res = await fetch(API_BASE + "/orders/export.csv");
  if (!res.ok){
    const text = await res.text();
    throw new Error(text || ("HTTP " + res.status));
  }
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "orders-export.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function loadHistory(opts={}){
  const resetOffset = !!opts.resetOffset;
  if (resetOffset) historyState.offset = 0;
  historyState.loading = true;
  setHistoryStatus("Loading history…");
  updateHistoryOfflineBadge();
  historyPageEl.textContent = String(Math.floor(historyState.offset / historyState.limit) + 1);

  try{
    const data = await fetchOrders({
      query: historyState.query || undefined,
      status: historyState.status || undefined,
      limit: historyState.limit,
      offset: historyState.offset
    });
    historyState.items = data.items || [];
    historyState.hasMore = !!data.has_more;
    historyState.offline = false;
    historyState.loadedOnce = true;
    historyState.needsRefresh = false;
    updateHistoryCache(historyState.items);
    analysisState.allOrdersDirty = true;
    renderOrdersList();
    updateHistoryOfflineBadge();
    setHistoryStatus(historyState.items.length ? "" : "No saved orders yet.");
  }catch(error){
    const cached = readHistoryCache();
    if (cached.length){
      historyState.items = historyState.status
        ? cached.filter(item => (item.status || "").toLowerCase() === historyState.status.toLowerCase())
        : cached;
      historyState.hasMore = false;
      historyState.offline = true;
      historyState.loadedOnce = true;
      historyState.needsRefresh = false;
      renderOrdersList();
      updateHistoryOfflineBadge();
      setHistoryStatus("Offline mode — showing cached results.");
      analysisState.allOrdersDirty = true;
    }else{
      historyState.items = [];
      renderOrdersList();
      setHistoryStatus("Unable to load history: " + (error.message || error));
    }
  }finally{
    historyState.loading = false;
    historyPageEl.textContent = String(Math.floor(historyState.offset / historyState.limit) + 1);
    updateHistoryControls();
  }
}

function updateHistoryControls(){
  document.getElementById("historyPrev").disabled = historyState.offset <= 0 || historyState.loading;
  document.getElementById("historyNext").disabled = historyState.loading || !historyState.hasMore;
}

function renderOrdersList(){
  const container = document.getElementById("historyListWrap");
  if (!historyState.items.length){
    container.innerHTML = '<div class="empty-state">No orders found.</div>';
    return;
  }
  const rows = historyState.items.map(order=>{
    const orderNumbers = (order.order_numbers || []).join(", ") || "—";
    const client = order.client || order.client_hint || "—";
    const source = order.source || "—";
    const created = formatDate(order.created_at);
    const status = (order.status || "").toUpperCase();
    const csvDisabled = status !== "APPROVED" ? "disabled" : "";
    return `<tr data-id="${order.id}">
      <td>${created}</td>
      <td>${orderNumbers}</td>
      <td>${client}</td>
      <td><span class="pill">${source}</span></td>
      <td>${order.units_total || 0}</td>
      <td>${formatArea(order.area_total)}</td>
      <td><span class="pill ${status === 'APPROVED' ? '' : 'warn'}">${status || "—"}</span></td>
      <td class="actions-cell">
        <button class="btn small" data-action="open" data-id="${order.id}">Open</button>
        <button class="btn small" data-action="processing" data-id="${order.id}">Processing</button>
        <button class="btn small" data-action="csv" data-id="${order.id}" ${csvDisabled}>CSV</button>
        <button class="btn small" data-action="print" data-id="${order.id}">Labels</button>
        <button type="button" class="btn small danger" data-history-delete="${order.id}">Delete</button>
      </td>
    </tr>`;
  }).join("");
  container.innerHTML = `<table>
    <thead>
      <tr>
        <th>Date / Time</th>
        <th>Order Numbers</th>
        <th>Client</th>
        <th>Source</th>
        <th>Units</th>
        <th>Area</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>${rows}</tbody>
  </table>`;
}

async function openOrderFromList(id){
  if (!id) return;
  historyMetaEl.textContent = "Loading order…";
  historyDetailEmpty.style.display = "none";
  historyPrintBtn.disabled = true;
  historyCsvBtn.disabled = true;
  try{
    const order = await fetchOrder(id);
    historyState.selectedOrder = order;
    renderOrderDetail();
  }catch(error){
    setHistoryStatus("Failed to load order: " + (error.message || error));
  }
}

function renderOrderDetail(){
  const order = historyState.selectedOrder;
  if (!order){
    appState.historyDetail.order = null;
    appState.historyDetail.rows = [];
    appState.historyDetail.rowWarnings = {};
    appState.historyDetail.warnings = [];
    appState.historyDetail.notes = "";
    updateHistoryDetailUI();
    return;
  }

  appState.historyDetail.order = order;
  const rows = Array.isArray(order.rows) ? order.rows.map(row => ({ ...row })) : [];
  const warningsSource = order.row_warnings || {};
  const warningsMap = {};
  appState.historyDetail.nextRid = 0;
  const timestampBase = Date.now();
  appState.historyDetail.rows = rows.map((row, idx) => {
    const rid = row._rid || `hist-${timestampBase}-${appState.historyDetail.nextRid++}`;
    const enriched = { ...row, _rid: rid };
    const rowWarn = Array.isArray(warningsSource)
      ? warningsSource[idx]
      : warningsSource[idx] || warningsSource[rid];
    if (rowWarn && rowWarn.length){
      warningsMap[rid] = rowWarn;
    }
    return enriched;
  });
  appState.historyDetail.rowWarnings = warningsMap;
  appState.historyDetail.warnings = order.warnings || [];
  appState.historyDetail.notes = order.notes || "";
  appState.historyDetail.declaredUnits = order.declared_units ?? null;
  appState.historyDetail.declaredArea = order.declared_area ?? null;
  appState.historyDetail.parsedUnits = order.parsed_units ?? null;
  appState.historyDetail.parsedArea = order.parsed_area ?? null;
  updateHistoryDetailUI();
}

document.getElementById("historyListWrap").addEventListener("click", async (event)=>{
  const btn = event.target.closest("button[data-action]");
  if (!btn) return;
  const rawId = btn.dataset.id;
  if (rawId == null || rawId === "") return;
  const numericId = Number(rawId);
  const id = Number.isFinite(numericId) ? numericId : rawId;
  const action = btn.dataset.action;
  if (action === "open"){
    await openOrderFromList(id);
  }else if (action === "processing"){
    try{
      await sendOrderToProcessing(id);
      setHistoryStatus("Added to Processing.");
    }catch(error){
      setHistoryStatus("Failed to add to Processing: " + (error.message || error));
    }
  }else if (action === "csv"){
    try{
      await downloadOrderCsv(id);
      setHistoryStatus("");
    }catch(error){
      setHistoryStatus("Download failed: " + (error.message || error));
    }
  }else if (action === "print"){
    try{
      const order = await fetchOrder(id);
      if (order.rows && order.rows.length){
        await handlePrint(order.rows);
        setHistoryStatus("Labels ready.");
      }else{
        setHistoryStatus("No rows to print for this order.");
      }
    }catch(error){
      setHistoryStatus("Failed to generate labels: " + (error.message || error));
    }
  }
});

document.getElementById("historyListWrap").addEventListener("click", async (event)=>{
  const btn = event.target.closest("[data-history-delete]");
  if (!btn) return;
  const rawId = btn.dataset.historyDelete;
  if (rawId == null || rawId === "") return;
  const numericId = Number(rawId);
  const id = Number.isFinite(numericId) ? numericId : rawId;
  if (!confirm(`Delete order #${id}?`)) return;
  const previousText = btn.textContent;
  btn.disabled = true;
  btn.textContent = "Deleting...";
  try{
    await deleteOrder(id);
    removeFromHistoryCache(id);
    analysisState.orderRowCache.delete(id);
    analysisState.allOrdersDirty = true;
    if (historyState.selectedOrder && String(historyState.selectedOrder.id) === String(id)){
      historyState.selectedOrder = null;
      renderOrderDetail();
    }
    const rowEl = btn.closest("tr");
    if (rowEl) rowEl.remove();
    historyState.items = historyState.items.filter(order => String(order.id) !== String(id));
    historyState.needsRefresh = true;
    await ensureHistoryLoaded();
    setHistoryStatus("Order deleted.");
  }catch(error){
    console.warn("History delete failed", error);
    alert("Failed to delete order.");
    btn.disabled = false;
    btn.textContent = previousText || "Delete";
  }
});

document.getElementById("historyPrev").addEventListener("click", ()=>{
  if (historyState.offset <= 0) return;
  historyState.offset = Math.max(historyState.offset - historyState.limit, 0);
  loadHistory();
});

document.getElementById("historyNext").addEventListener("click", ()=>{
  if (!historyState.hasMore) return;
  historyState.offset += historyState.limit;
  loadHistory();
});

document.getElementById("historyRefresh").addEventListener("click", ()=>{
  loadHistory();
});

document.getElementById("historyDownloadAll").addEventListener("click", async ()=>{
  setHistoryStatus("Preparing CSV export…");
  try{
    await downloadAllCsv();
    setHistoryStatus("Export ready.");
  }catch(error){
    setHistoryStatus("Failed to export: " + (error.message || error));
  }
});

document.getElementById("historyCsv").addEventListener("click", async ()=>{
  const order = historyState.selectedOrder;
  if (!order) return;
  try{
    await downloadOrderCsv(order.id);
    setHistoryStatus("");
  }catch(error){
    setHistoryStatus("Download failed: " + (error.message || error));
  }
});

document.getElementById("historyProcessing").addEventListener("click", async ()=>{
  const order = historyState.selectedOrder;
  if (!order) return;
  try{
    await sendOrderToProcessing(order.id);
    setHistoryStatus("Added to Processing.");
  }catch(error){
    setHistoryStatus("Failed to add to Processing: " + (error.message || error));
  }
});

if (processingOrderList){
  processingOrderList.addEventListener("click", (event)=>{
    const btn = event.target.closest("[data-remove-processing]");
    if (!btn) return;
    const id = btn.dataset.removeProcessing;
    if (!id) return;
    removeOrderFromProcessing(id);
    setStatusMessage("Order removed from Processing.");
  });
}

if (processingClearBtn){
  processingClearBtn.addEventListener("click", ()=>{
    clearProcessing();
    setStatusMessage("Processing sheet cleared.");
  });
}

if (processingRoundingBtn){
  processingRoundingBtn.addEventListener("click", ()=>{
    const active = isProcessingRoundingActive();
    if (active){
      appState.processing.rounding.manualApplied = false;
      if (appState.processing.options.autoDanko){
        appState.processing.options.autoDanko = false;
        if (processingAutoDankoToggle) processingAutoDankoToggle.checked = false;
      }
      setProcessingRoundingMessage("Rounded values removed.");
    }else{
      appState.processing.rounding.manualApplied = true;
      setProcessingRoundingMessage("Rounded values applied using Danko Rule ✅");
    }
    applyProcessingRoundingToRows();
    recalcProcessingPreview();
    updateProcessingUI();
  });
}

if (processingAutoDankoToggle){
  processingAutoDankoToggle.addEventListener("change", event => {
    appState.processing.options.autoDanko = !!event.target.checked;
    if (appState.processing.options.autoDanko){
      appState.processing.rounding.manualApplied = false;
      setProcessingRoundingMessage("Auto Danko rounding enabled. ✅");
    }else{
      setProcessingRoundingMessage("Auto Danko rounding disabled.");
    }
    applyProcessingRoundingToRows();
    recalcProcessingPreview();
    updateProcessingUI();
  });
}

if (processingGroupBtn){
  processingGroupBtn.addEventListener("click", ()=>{
    appState.processing.grouped = !appState.processing.grouped;
    rebuildProcessingRows();
    updateProcessingUI();
    setStatusMessage(appState.processing.grouped ? "Dimensions grouped." : "Grouping disabled.");
  });
}

if (processingRestartToggle){
  processingRestartToggle.addEventListener("change", (event)=>{
    appState.processing.options.restartPerGroup = !!event.target.checked;
    rebuildProcessingRows();
    updateProcessingUI();
  });
}

if (processingNormalizeToggle){
  processingNormalizeToggle.addEventListener("change", (event)=>{
    appState.processing.options.normalizeLPtoG = !!event.target.checked;
    rebuildProcessingRows();
    updateProcessingUI();
  });
}

if (processingDecimalSelect){
  processingDecimalSelect.addEventListener("change", (event)=>{
    appState.processing.options.decimalSeparator = event.target.value === "dot" ? "dot" : "comma";
    rebuildProcessingRows();
    updateProcessingUI();
  });
}

if (processingMergeOrdersToggle){
  processingMergeOrdersToggle.addEventListener("change", (event)=>{
    appState.processing.options.mergeAcrossOrders = !!event.target.checked;
    rebuildProcessingRows();
    updateProcessingUI();
  });
}

if (processingHeaderSelect){
  processingHeaderSelect.addEventListener("change", ()=>{
    syncProcessingHeaderEditor();
  });
}

if (processingHeaderApply){
  processingHeaderApply.addEventListener("click", ()=>{
    if (!processingHeaderSelect || processingHeaderSelect.disabled) return;
    if (!processingHeaderInput) return;
    const raw = processingHeaderSelect.value;
    if (!raw) return;
    const value = (processingHeaderInput.value || "").trim();
    if (value){
      appState.processing.headerOverrides[raw] = value;
    }else{
      delete appState.processing.headerOverrides[raw];
    }
    rebuildProcessingRows();
    updateProcessingUI();
  });
}

if (processingHeaderReset){
  processingHeaderReset.addEventListener("click", ()=>{
    if (!processingHeaderSelect || processingHeaderSelect.disabled) return;
    const raw = processingHeaderSelect.value;
    if (!raw) return;
    delete appState.processing.headerOverrides[raw];
    rebuildProcessingRows();
    updateProcessingUI();
  });
}

if (processingCopyBtn){
  processingCopyBtn.addEventListener("click", ()=>{ copyProcessingText(); });
}

if (processingExportPdfBtn){
  processingExportPdfBtn.addEventListener("click", async ()=>{
    try{
      await exportProcessingPdf();
    }catch(error){
      setStatusMessage("PDF export failed: " + (error.message || error));
    }
  });
}

if (processingExportCsvBtn){
  processingExportCsvBtn.addEventListener("click", ()=>{
    try{
      exportProcessingCsv();
    }catch(error){
      setStatusMessage("CSV export failed: " + (error.message || error));
    }
  });
}

if (labelsFromProcessingBtn){
  labelsFromProcessingBtn.addEventListener("click", ()=>{
    addLabelJobsFromProcessing();
  });
}

if (labelsFromProcessingDownloadBtn){
  labelsFromProcessingDownloadBtn.addEventListener("click", async ()=>{
    const processingCount = appState.processing.cart ? appState.processing.cart.length : 0;
    if (!processingCount){
      setLabelsStatus("Processing is empty.");
      return;
    }
    if (processingCount < 2){
      setLabelsStatus("Add at least two orders in Processing to download combined labels.");
      return;
    }
    const result = addLabelJobsFromProcessing({ silent: true }) || { addedJobs: [], skipped: [], totalRows: 0 };
    if (!result.addedJobs.length){
      if (!result.skipped.length){
        setLabelsStatus("No orders added from Processing.");
      }else{
        setLabelsStatus(`Skipped: ${result.skipped.join(", ")}`);
      }
      return;
    }
    const combinedRows = result.addedJobs.flatMap(job => Array.isArray(job.rows) ? job.rows : []);
    if (!combinedRows.length){
      const skipNote = result.skipped.length ? ` Skipped: ${result.skipped.join(", ")}` : "";
      setLabelsStatus(`Added ${result.addedJobs.length} orders but no rows available.${skipNote}`);
      return;
    }
    try{
      await handlePrint(combinedRows);
      const skipNote = result.skipped.length ? ` Skipped: ${result.skipped.join(", ")}` : "";
      setLabelsStatus(`Added ${result.addedJobs.length} orders (${result.totalRows} rows) and downloaded combined labels.${skipNote}`);
    }catch(error){
      console.error("Combined labels download failed", error);
      setLabelsStatus("Error generating combined labels.");
    }
  });
}

if (labelsFromHistoryBtn){
  labelsFromHistoryBtn.addEventListener("click", ()=>{
    const rows = appState.historyDetail.rows || [];
    if (!rows.length){
      setLabelsStatus("Select an order in History first.");
      return;
    }
    const sourceLabel = historyState.selectedOrder
      ? `History #${historyState.selectedOrder.id}`
      : "History selection";
    addLabelsJob(sourceLabel, rows, {
      formatMessage: (job)=>{
        const orders = job.orders.length ? job.orders.join(", ") : "no order number";
        const labelWord = job.labels === 1 ? "label" : "labels";
        return `Added ${job.labels} ${labelWord} from history (${orders}).`;
      }
    });
  });
}

if (labelsClearBtn){
  labelsClearBtn.addEventListener("click", ()=>{
    if (!appState.labels.jobs.length){
      setLabelsStatus("No label jobs to clear.");
      return;
    }
    appState.labels.jobs = [];
    setLabelsStatus("Cleared label jobs.");
    updateLabelsUI();
  });
}

if (labelsJobsWrap){
  labelsJobsWrap.addEventListener("click", async (event)=>{
    const btn = event.target.closest("button[data-action]");
    if (!btn) return;
    const id = btn.dataset.id;
    const action = btn.dataset.action;
    if (!id || !action) return;
    const index = appState.labels.jobs.findIndex(job => job.id === id);
    if (index < 0){
      setLabelsStatus("Label job not found.");
      return;
    }
    const job = appState.labels.jobs[index];
    if (action === "labels-download"){
      try{
        await handlePrint(job.rows);
        setLabelsStatus("Labels ready (downloaded).");
      }catch(error){
        console.error("Label download failed", error);
        setLabelsStatus("Error generating labels.");
      }
    }else if (action === "labels-remove"){
      appState.labels.jobs.splice(index, 1);
      setLabelsStatus("Label job removed.");
      updateLabelsUI();
    }
  });
}

document.getElementById("historyApprove").addEventListener("click", async ()=>{
  const order = historyState.selectedOrder;
  if (!order) return;
  if ((order.status || "").toLowerCase() !== "draft"){
    setHistoryStatus("This order is already approved.");
    return;
  }
  const rows = (appState.historyDetail.rows || []).map(row => ({
    order_number: row.order_number || "",
    type: row.type || "",
    dimension: row.dimension || "",
    position: row.position || "",
    quantity: Number(row.quantity || 0),
    area: Number(row.area || 0),
  }));
  setHistoryStatus("Approving draft…");
  try{
    const resp = await approveDraft(order.id, rows, appState.historyDetail.notes);
    setHistoryStatus("Order approved.");
    historyState.needsRefresh = true;
    analysisState.allOrdersDirty = true;
    analysisState.orderRowCache.delete(order.id);
    try{
      await loadHistory({ resetOffset: false });
    }catch(err){
      console.warn("History refresh failed after approval", err);
    }
    try{
      const refreshed = await fetchOrder(order.id);
      historyState.selectedOrder = refreshed;
      renderOrderDetail();
    }catch(err){
      console.warn("Failed to reload approved order", err);
    }
    showSavedToast(resp?.saved_order_id || order.id);
  }catch(error){
    console.error("Order approval failed", error);
    let fallbackHandled = false;
    // Try to reload the order detail directly
    try{
      const snapshot = await fetchOrder(order.id);
      if (snapshot && (snapshot.status || "").toLowerCase() === "approved"){
        historyState.selectedOrder = snapshot;
        renderOrderDetail();
        historyState.needsRefresh = true;
        analysisState.allOrdersDirty = true;
        analysisState.orderRowCache.delete(order.id);
        try{
          await loadHistory({ resetOffset: false });
        }catch(loadErr){
          console.warn("History refresh failed after fallback", loadErr);
        }
        setHistoryStatus("Order approved (auto-recovered).");
        showSavedToast(snapshot.id || order.id);
        fallbackHandled = true;
      }
    }catch(fallbackErr){
      console.warn("Fallback approval fetch failed", fallbackErr);
    }

    // If direct fetch failed, see whether the history list already shows the order as approved
    if (!fallbackHandled){
      try{
        await loadHistory({ resetOffset: false });
        const inHistory = historyState.items.find(item => item.id === order.id);
        if (inHistory && (inHistory.status || "").toLowerCase() === "approved"){
          historyState.selectedOrder = await fetchOrder(order.id).catch(()=> ({ ...order, status: "approved" }));
          renderOrderDetail();
          setHistoryStatus("Order approved (history shows success).");
          showSavedToast(order.id);
          analysisState.allOrdersDirty = true;
          analysisState.orderRowCache.delete(order.id);
          fallbackHandled = true;
        }
      }catch(historyErr){
        console.warn("History reload after approval error failed", historyErr);
      }
    }

    if (!fallbackHandled){
      setHistoryStatus("Approval failed: " + (error && error.message ? error.message : String(error)));
    }
  }
});

document.getElementById("historyPrint").addEventListener("click", async ()=>{
  const rows = getDisplayedRows("history");
  if (!rows.length){
    setHistoryStatus("No rows to print.");
    return;
  }
  setHistoryStatus("Generating labels…");
  try{
    await handlePrint(rows);
    setHistoryStatus("Labels ready.");
  }catch(error){
    setHistoryStatus("Failed to generate labels: " + (error.message || error));
  }
});

document.getElementById("historyLimit").addEventListener("change", (event)=>{
  historyState.limit = Number(event.target.value) || 25;
  historyState.offset = 0;
  loadHistory({ resetOffset: true });
});

document.getElementById("historyStatusFilter").addEventListener("change", (event)=>{
  historyState.status = event.target.value || "";
  historyState.offset = 0;
  loadHistory({ resetOffset: true });
});

let historySearchTimer = null;
document.getElementById("historySearch").addEventListener("input", (event)=>{
  const value = event.target.value.trim();
  historyState.query = value;
  historyState.offset = 0;
  clearTimeout(historySearchTimer);
  historySearchTimer = setTimeout(()=> loadHistory({ resetOffset: true }), 250);
});

// ---------- LLM extraction + PDF handling -----------------------------------
async function callAPI(text){
  setErrorMessage("");
  setStatusMessage('<span class="spinner"></span> Extracting…');
  const res = await fetch(API_BASE + "/extract", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text })
  });
  if (!res.ok){
    const message = await res.text();
    throw new Error(message || ("HTTP " + res.status));
  }
  const data = await res.json();
  setStatusMessage("Done.");
  return data;
}

async function callPdfAPI(file){
  setErrorMessage("");
  setStatusMessage('<span class="spinner"></span> Extracting PDF…');
  const formData = new FormData();
  formData.append("file", file, file.name || "upload.pdf");
  const res = await fetch(API_BASE + "/extract_pdf", {
    method: "POST",
    body: formData
  });
  if (!res.ok){
    const message = await res.text();
    throw new Error(message || ("HTTP " + res.status));
  }
  const data = await res.json();
  setStatusMessage("Done.");
  return data;
}

async function approveDraft(orderId, rows, notes){
  const res = await fetch(`${API_BASE}/orders/${orderId}/approve`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ rows, notes: notes || undefined })
  });
  if (!res.ok){
    const text = await res.text();
    throw new Error(text || (`HTTP ${res.status}`));
  }
  return res.json();
}

function applyExtractionResult(data){
  const rows = Array.isArray(data?.rows) ? data.rows.map(row => ({ ...row })) : [];
  const warningsSource = data?.row_warnings || {};
  appState.extract.nextRid = 0;
  const warningsMap = {};
  const timestampBase = Date.now();
  appState.extract.rows = rows.map((row, idx) => {
    const rid = row._rid || `ex-${timestampBase}-${appState.extract.nextRid++}`;
    const enriched = { ...row, _rid: rid };
    const rowWarn = Array.isArray(warningsSource)
      ? warningsSource[idx]
      : warningsSource[idx] || warningsSource[rid];
    if (rowWarn && rowWarn.length){
      warningsMap[rid] = rowWarn;
    }
    return enriched;
  });
  appState.extract.rowWarnings = warningsMap;
  appState.extract.warnings = data?.warnings || [];
  appState.extract.draftId = data?.draft_order_id || null;
  appState.extract.status = data?.status || (data?.saved_order_id ? "approved" : "draft");
  appState.extract.savedOrderId = data?.saved_order_id || null;
  appState.extract.orderNumber = data?.order_number || "";
  appState.extract.appliedCorrections = data?.applied_corrections || [];
  appState.extract.notes = "";
  appState.extract.declaredUnits = data?.declared_units ?? null;
  appState.extract.declaredArea = data?.declared_area ?? null;
  appState.extract.parsedUnits = data?.parsed_units ?? null;
  appState.extract.parsedArea = data?.parsed_area ?? null;
  appState.extract.client = data?.client || "—";
  historyState.needsRefresh = true;
  analysisState.allOrdersDirty = true;
  if (data?.saved_order_id){
    analysisState.orderRowCache.delete(data.saved_order_id);
  }
  updateExtractUI();
  if (data?.saved_order_id){
    showSavedToast(data.saved_order_id);
  }
}

async function handleTextExtraction(text){
  const value = (text || "").trim();
  if (!value) return;
  try{
    const data = await callAPI(value);
    applyExtractionResult(data);
  }catch(error){
    setStatusMessage("");
    setErrorMessage("Error: " + (error.message || error));
  }
}

async function handlePdfExtraction(file){
  if (!file) return;
  try{
    const data = await callPdfAPI(file);
    applyExtractionResult(data);
  }catch(error){
    setStatusMessage("");
    setErrorMessage("Error: " + (error.message || error));
  }
}

document.getElementById("extract").addEventListener("click", async ()=>{
  const text = document.getElementById("input").value.trim();
  if (!text) return;
  await handleTextExtraction(text);
});

document.getElementById("rerun").addEventListener("click", async ()=>{
  const text = document.getElementById("input").value.trim();
  if (!text) return;
  await handleTextExtraction(text);
});

document.getElementById("approveSave").addEventListener("click", async ()=>{
  const draftId = appState.extract.draftId;
  if (!draftId){
    setStatusMessage("No draft to approve yet.");
    return;
  }
  const rows = (appState.extract.rows || []).map(row => ({
    order_number: row.order_number || "",
    type: row.type || "",
    dimension: row.dimension || "",
    position: row.position || "",
    quantity: Number(row.quantity || 0),
    area: Number(row.area || 0),
  }));
  setStatusMessage("Approving draft…");
  try{
    const resp = await approveDraft(draftId, rows, appState.extract.notes);
    const updatedRows = Array.isArray(resp?.order?.rows) ? resp.order.rows.map(r => ({ ...r })) : rows;
    const warningsSource = resp?.row_warnings || {};
    const warningsMap = {};
    const timestampBase = Date.now();
    appState.extract.nextRid = 0;
    appState.extract.rows = updatedRows.map((row, idx) => {
      const rid = row._rid || `ex-${timestampBase}-${appState.extract.nextRid++}`;
      const enriched = { ...row, _rid: rid };
      const rowWarn = Array.isArray(warningsSource)
        ? warningsSource[idx]
        : warningsSource[idx] || warningsSource[rid];
      if (rowWarn && rowWarn.length){
        warningsMap[rid] = rowWarn;
      }
      return enriched;
    });
    appState.extract.rowWarnings = warningsMap;
    appState.extract.warnings = resp?.warnings || [];
    appState.extract.draftId = null;
    appState.extract.status = "approved";
    appState.extract.savedOrderId = resp?.saved_order_id || draftId;
    appState.extract.declaredUnits = resp?.declared_units ?? appState.extract.declaredUnits;
    appState.extract.declaredArea = resp?.declared_area ?? appState.extract.declaredArea;
    appState.extract.parsedUnits = resp?.parsed_units ?? appState.extract.parsedUnits;
    appState.extract.parsedArea = resp?.parsed_area ?? appState.extract.parsedArea;
    updateExtractUI();
    historyState.needsRefresh = true;
    analysisState.allOrdersDirty = true;
    analysisState.orderRowCache.delete(resp?.saved_order_id || draftId);
    loadHistory();
    setStatusMessage("Order approved.");
    if (resp?.saved_order_id){
      showSavedToast(resp.saved_order_id);
    }
  }catch(error){
    setStatusMessage("Approval failed.");
    setErrorMessage("Approval error: " + (error.message || error));
  }
});

document.getElementById("copyCsv").addEventListener("click", async ()=>{
  const rows = getDisplayedRows("extract");
  if (!rows.length){
    setStatusMessage("Nothing to copy.");
    return;
  }
  const csv = toCSV(rows);
  try{
    await navigator.clipboard.writeText(csv);
    setStatusMessage("CSV copied.");
  }catch{
    setStatusMessage("Copy failed — select and copy manually.");
  }
});

document.getElementById("downloadCsv").addEventListener("click", ()=>{
  const rows = getDisplayedRows("extract");
  if (!rows.length){
    setStatusMessage("Nothing to download.");
    return;
  }
  const csv = toCSV(rows);
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "order.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

async function handlePrint(rows){
  if (!rows || !rows.length){
    throw new Error("No rows to print.");
  }
  const pdfBytes = await generateLabelsPdf(rows);
  const blob = new Blob([pdfBytes], { type: "application/pdf" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "labels.pdf";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

document.getElementById("printLabels").addEventListener("click", async ()=>{
  const rows = getDisplayedRows("extract");
  if (!rows.length){
    setStatusMessage("No rows to print — extract first.");
    return;
  }
  setStatusMessage("Generating labels…");
  try{
    await handlePrint(rows);
    setStatusMessage("Labels ready (downloaded).");
  }catch(error){
    console.error(error);
    setStatusMessage("Error generating labels.");
  }
});

function isPdfFile(file){
  if (!file) return false;
  const type = (file.type || "").toLowerCase();
  const name = (file.name || "").toLowerCase();
  return type === "application/pdf" || name.endsWith(".pdf");
}

function isPlainTextFile(file){
  if (!file) return false;
  const type = (file.type || "").toLowerCase();
  const name = (file.name || "").toLowerCase();
  return type.startsWith("text/") || name.endsWith(".txt");
}

(function(){
  const dropZone = document.getElementById("pdfDropZone");
  const fileInput = document.getElementById("pdfInput");
  if (!dropZone || !fileInput) return;

  const prevent = (event)=>{
    event.preventDefault();
    event.stopPropagation();
  };

  ["dragenter","dragover"].forEach(evt=>{
    dropZone.addEventListener(evt, (event)=>{
      prevent(event);
      dropZone.classList.add("hover");
      if (event.dataTransfer) event.dataTransfer.dropEffect = "copy";
    });
  });

  ["dragleave","dragend"].forEach(evt=>{
    dropZone.addEventListener(evt, (event)=>{
      prevent(event);
      dropZone.classList.remove("hover");
    });
  });

  dropZone.addEventListener("drop", async (event)=>{
    prevent(event);
    dropZone.classList.remove("hover");
    setErrorMessage("");
    const files = event.dataTransfer && event.dataTransfer.files;
    if (files && files.length){
      const file = files[0];
      if (isPdfFile(file)){
        await handlePdfExtraction(file);
        return;
      }
      if (isPlainTextFile(file)){
        const text = await file.text();
        if (text && text.trim()){
          document.getElementById("input").value = text;
          await handleTextExtraction(text);
          return;
        }
      }
    }
    const textData = event.dataTransfer ? event.dataTransfer.getData("text") : "";
    if (textData && textData.trim()){
      document.getElementById("input").value = textData;
      await handleTextExtraction(textData);
      return;
    }
    setStatusMessage("Unsupported drop. Use a PDF or text.");
  });

  dropZone.addEventListener("click", ()=> fileInput.click());
  fileInput.addEventListener("change", async (event)=>{
    const file = event.target.files && event.target.files[0];
    event.target.value = "";
    if (!file) return;
    if (!isPdfFile(file)){
      setStatusMessage("Please choose a PDF file.");
      return;
    }
    await handlePdfExtraction(file);
  });
})();

// --------- Label helper utilities (unchanged core) -------------------------
function dataURLToBytes(dataUrl){
  try{
    const base64 = (dataUrl.split(",")[1] || "");
    const bin = atob(base64);
    const len = bin.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }catch{
    return null;
  }
}

function bytesToDataURL(bytes){
  if (!bytes) return null;
  const arr = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
  let binary = "";
  const chunk = 0x8000;
  for (let i = 0; i < arr.length; i += chunk){
    const slice = arr.subarray(i, i + chunk);
    binary += String.fromCharCode.apply(null, slice);
  }
  return "data:image/png;base64," + btoa(binary);
}

function fileToDataURL(file){
  return new Promise((resolve, reject)=>{
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

async function ensurePdfLib(){
  if (window.PDFLib) return;
  await new Promise((resolve, reject)=>{
    const script = document.createElement("script");
    script.src = "https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js";
    script.onload = resolve;
    script.onerror = ()=> reject(new Error("Failed to load pdf-lib"));
    document.head.appendChild(script);
  });
}

const mmToPt = 2.83464567;
const pageSize = { w: 100 * mmToPt, h: 40 * mmToPt };

async function loadLogoCandidates(name){
  const basePath = window.location.pathname.replace(/[^/]*$/, "");
  const candidates = [
    `${name}.png`, `${name}.PNG`,
    `${basePath}${name}.png`, `${basePath}${name}.PNG`,
    `assets/${name}.png`, `assets/${name}.PNG`
  ];
  for (const path of candidates){
    try{
      const res = await fetch(path, { cache: "no-cache" });
      if (res.ok){
        const buffer = await res.arrayBuffer();
        return new Uint8Array(buffer);
      }
    }catch{/* ignore */}
  }
  return null;
}

function dataUrlFromImage(img){
  try{
    const canvas = document.createElement("canvas");
    canvas.width = img.naturalWidth || img.width;
    canvas.height = img.naturalHeight || img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);
    return canvas.toDataURL("image/png");
  }catch{
    return null;
  }
}

async function loadLogoViaImage(name){
  const basePath = window.location.pathname.replace(/[^/]*$/, "");
  const candidates = [
    `${name}.png`, `${name}.PNG`,
    `${basePath}${name}.png`, `${basePath}${name}.PNG`,
    `assets/${name}.png`, `assets/${name}.PNG`
  ];
  for (const src of candidates){
    const found = await new Promise((resolve)=>{
      const img = new Image();
      img.onload = ()=>{
        const dataUrl = dataUrlFromImage(img);
        if (!dataUrl) return resolve(null);
        try{
          const bytes = dataURLToBytes(dataUrl);
          resolve(bytes);
        }catch{
          resolve(null);
        }
      };
      img.onerror = ()=> resolve(null);
      img.src = src;
    });
    if (found && found.byteLength) return found;
  }
  return null;
}

async function preloadLogos(){
  let keliBytes = null;
  let ceBytes = null;
  const localKeli = localStorage.getItem("logo_keli_b64");
  const localCe = localStorage.getItem("logo_ce_b64");
  if (localKeli) keliBytes = dataURLToBytes(localKeli);
  if (localCe) ceBytes = dataURLToBytes(localCe);
  if (!keliBytes) keliBytes = await loadLogoViaImage("logokeli");
  if (!ceBytes) ceBytes = await loadLogoViaImage("ce");
  if (!keliBytes){
    const fetched = await loadLogoCandidates("logokeli");
    if (fetched && fetched.byteLength){
      keliBytes = fetched;
      try{
        const dataUrl = bytesToDataURL(fetched);
        if (dataUrl) localStorage.setItem("logo_keli_b64", dataUrl);
      }catch{/* ignore storage errors */}
    }
  }
  if (!ceBytes){
    const fetched = await loadLogoCandidates("ce");
    if (fetched && fetched.byteLength){
      ceBytes = fetched;
      try{
        const dataUrl = bytesToDataURL(fetched);
        if (dataUrl) localStorage.setItem("logo_ce_b64", dataUrl);
      }catch{/* ignore storage errors */}
    }
  }
  return { keliBytes, ceBytes };
}

async function generateLabelsPdf(rows){
  await ensurePdfLib();
  const { PDFDocument, StandardFonts } = PDFLib;
  const pdfDoc = await PDFDocument.create();
  const bold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  const regular = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const { keliBytes, ceBytes } = await preloadLogos();
  let keliImg, ceImg;
  if (keliBytes){
    const data = keliBytes instanceof Uint8Array ? keliBytes : new Uint8Array(keliBytes);
    keliImg = await pdfDoc.embedPng(data);
  }
  if (ceBytes){
    const data = ceBytes instanceof Uint8Array ? ceBytes : new Uint8Array(ceBytes);
    ceImg = await pdfDoc.embedPng(data);
  }
  const today = new Date().toLocaleDateString("en-GB").replaceAll("/", ".");
  for (const row of rows){
    const qty = Number(row.quantity || 0) || 1;
    for (let i = 0; i < qty; i++){
      const page = pdfDoc.addPage([pageSize.w, pageSize.h]);
      const margin = 16;
      const spacing = 12;
      let y = pageSize.h - margin;
      if (keliImg) page.drawImage(keliImg, { x: margin, y: y - 20, width: 60, height: 20 });
      if (ceImg) page.drawImage(ceImg, { x: (pageSize.w - 30) / 2, y: y - 18, width: 30, height: 18 });
      page.drawText(today, { x: pageSize.w - margin - 60, y: y - 14, size: 10, font: bold });
      page.drawLine({ start: { x: margin, y: y - 24 }, end: { x: pageSize.w - margin, y: y - 24 }, thickness: 0.8 });
      y -= (24 + spacing);
      const dimension = row.dimension && row.dimension.length ? row.dimension : "—";
      const position = row.position || "—";
      const orderNo = row.order_number || "—";
      const type = row.type || "";
      page.drawText(`Order No.: ${orderNo}   Pos: ${position}   Dim: ${dimension}`, {
        x: margin, y, size: 9, font: bold, maxWidth: pageSize.w - margin * 2
      });
      y -= 14;
      page.drawText(`Glass Type: ${type}`, { x: margin, y, size: 10, font: bold, maxWidth: pageSize.w - margin * 2 });
      y -= 16;
      page.drawText("KELI ALBANIA PVC", { x: margin, y, size: 10, font: regular });
    }
  }
  return pdfDoc.save();
}

(function(){
  const statusEl = document.getElementById("logoStatus");
  const setStatus = (msg)=> { if (statusEl) statusEl.textContent = msg; };
  const keliInput = document.getElementById("logoKeli");
  const ceInput = document.getElementById("logoCe");
  if (keliInput){
    keliInput.addEventListener("change", async (event)=>{
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      try{
        const dataUrl = await fileToDataURL(file);
        localStorage.setItem("logo_keli_b64", dataUrl);
        setStatus("Saved logokeli.png ✔");
      }catch{
        setStatus("Failed to save logokeli.");
      }
    });
  }
  if (ceInput){
    ceInput.addEventListener("change", async (event)=>{
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      try{
        const dataUrl = await fileToDataURL(file);
        localStorage.setItem("logo_ce_b64", dataUrl);
        setStatus("Saved ce.png ✔");
      }catch{
        setStatus("Failed to save ce.");
      }
    });
  }
})();

updateExtractUI();
updateHistoryDetailUI();
updateProcessingUI();
updateLabelsUI();
</script>
</body>
</html>
